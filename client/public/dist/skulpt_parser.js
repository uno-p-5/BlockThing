"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var Sk = {};

Sk.exportSymbol = function (name, module) {
  var parts = name.split(".");
  var submodule = Sk;
  var i;

  for (i = 1; i < parts.length - 1; i++) {
    if (!(parts[i] in submodule)) {
      submodule[parts[i]] = {};
    }
  }

  submodule[parts[i]] = module;
};

Sk.configure = function (options) {};

Sk.builtin = {
  SyntaxError: function SyntaxError(message, filename, lineno, position) {
    this.message = message;
    this.filename = filename;
    this.lineno = lineno;
    this.position = position;
  },
  str: function str(x) {
    if (x instanceof Sk.builtin.str) {
      return x;
    }

    if (!(this instanceof Sk.builtin.str)) {
      return new Sk.builtin.str(x);
    }

    this.v = x;
  },
  int_: function int_(n) {
    this.v = n;
  },
  float_: function float_(n) {
    this.v = n;
  },
  bool: {
    "true$": {
      v: true
    },
    "false$": {
      v: true
    }
  },
  none: {
    "none$": {
      v: null
    }
  }
};
Sk.builtin.int_.threshold$ = Infinity;

Sk.builtin.str.prototype.sq$concat = function (other) {
  return new Sk.builtin.str(this.v + other.v);
};

Sk.__future__ = {
  print_function: true,
  division: true,
  absolute_import: null,
  unicode_literals: true,
  // skulpt specific
  python3: true,
  set_repr: true,
  class_repr: true,
  inherit_from_object: true,
  super_args: true,
  octal_number_literal: true,
  bankers_rounding: true,
  python_version: true,
  dunder_next: true,
  dunder_round: true,
  list_clear: true,
  exceptions: true,
  no_long_type: true,
  ceil_floor_int: true,
  l_suffix: false,
  silent_octal_literal: false
};
Sk.asserts = {
  assert: function assert(condition) {
    if (!condition) {
      console.error(condition);
    }
  }
};
Sk.ffi = {
  remapToJs: function remapToJs(data) {
    return data.v;
  }
};
/* File automatically generated by asdl_js.py. */

/* Object that holds all nodes */

Sk.astnodes = {};
/* ----- expr_context ----- */

/** @constructor */

Sk.astnodes.Load = function Load() {};
/** @constructor */


Sk.astnodes.Store = function Store() {};
/** @constructor */


Sk.astnodes.Del = function Del() {};
/** @constructor */


Sk.astnodes.AugLoad = function AugLoad() {};
/** @constructor */


Sk.astnodes.AugStore = function AugStore() {};
/** @constructor */


Sk.astnodes.Param = function Param() {};
/* ----- boolop ----- */

/** @constructor */


Sk.astnodes.And = function And() {};
/** @constructor */


Sk.astnodes.Or = function Or() {};
/* ----- operator ----- */

/** @constructor */


Sk.astnodes.Add = function Add() {};
/** @constructor */


Sk.astnodes.Sub = function Sub() {};
/** @constructor */


Sk.astnodes.Mult = function Mult() {};
/** @constructor */


Sk.astnodes.MatMult = function MatMult() {};
/** @constructor */


Sk.astnodes.Div = function Div() {};
/** @constructor */


Sk.astnodes.Mod = function Mod() {};
/** @constructor */


Sk.astnodes.Pow = function Pow() {};
/** @constructor */


Sk.astnodes.LShift = function LShift() {};
/** @constructor */


Sk.astnodes.RShift = function RShift() {};
/** @constructor */


Sk.astnodes.BitOr = function BitOr() {};
/** @constructor */


Sk.astnodes.BitXor = function BitXor() {};
/** @constructor */


Sk.astnodes.BitAnd = function BitAnd() {};
/** @constructor */


Sk.astnodes.FloorDiv = function FloorDiv() {};
/* ----- unaryop ----- */

/** @constructor */


Sk.astnodes.Invert = function Invert() {};
/** @constructor */


Sk.astnodes.Not = function Not() {};
/** @constructor */


Sk.astnodes.UAdd = function UAdd() {};
/** @constructor */


Sk.astnodes.USub = function USub() {};
/* ----- cmpop ----- */

/** @constructor */


Sk.astnodes.Eq = function Eq() {};
/** @constructor */


Sk.astnodes.NotEq = function NotEq() {};
/** @constructor */


Sk.astnodes.Lt = function Lt() {};
/** @constructor */


Sk.astnodes.LtE = function LtE() {};
/** @constructor */


Sk.astnodes.Gt = function Gt() {};
/** @constructor */


Sk.astnodes.GtE = function GtE() {};
/** @constructor */


Sk.astnodes.Is = function Is() {};
/** @constructor */


Sk.astnodes.IsNot = function IsNot() {};
/** @constructor */


Sk.astnodes.In = function In() {};
/** @constructor */


Sk.astnodes.NotIn = function NotIn() {};
/* ---------------------- */

/* constructors for nodes */

/* ---------------------- */

/** @constructor */


Sk.astnodes.Module = function Module(
/* {asdl_seq *} */
body,
/* {string} */
docstring) {
  this.body = body;
  this.docstring = docstring;
  return this;
};
/** @constructor */


Sk.astnodes.Interactive = function Interactive(
/* {asdl_seq *} */
body) {
  this.body = body;
  return this;
};
/** @constructor */


Sk.astnodes.Expression = function Expression(
/* {expr_ty} */
body) {
  this.body = body;
  return this;
};
/** @constructor */


Sk.astnodes.Suite = function Suite(
/* {asdl_seq *} */
body) {
  this.body = body;
  return this;
};
/** @constructor */


Sk.astnodes.FunctionDef = function FunctionDef(
/* {identifier} */
name,
/*
{arguments__ty} */
args,
/*
{asdl_seq *} */
body,
/*
{asdl_seq *} */
decorator_list,
/*
{expr_ty} */
returns,
/*
{string} */
docstring,
/*
{int} */
lineno,
/* {int}
*/
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.name = name;
  this.args = args;
  this.body = body;
  this.decorator_list = decorator_list;
  this.returns = returns;
  this.docstring = docstring;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.AsyncFunctionDef = function AsyncFunctionDef(
/* {identifier} */
name,
/*
{arguments__ty}
*/
args,
/*
{asdl_seq *} */
body,
/*
{asdl_seq *} */
decorator_list,
/* {expr_ty} */
returns,
/*
{string} */
docstring,
/*
{int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.name = name;
  this.args = args;
  this.body = body;
  this.decorator_list = decorator_list;
  this.returns = returns;
  this.docstring = docstring;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.ClassDef = function ClassDef(
/* {identifier} */
name,
/* {asdl_seq
*} */
bases,
/* {asdl_seq *} */
keywords,
/* {asdl_seq *} */
body,
/* {asdl_seq *} */
decorator_list,
/* {string} */
docstring,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.name = name;
  this.bases = bases;
  this.keywords = keywords;
  this.body = body;
  this.decorator_list = decorator_list;
  this.docstring = docstring;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Return = function Return(
/* {expr_ty} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Delete = function Delete(
/* {asdl_seq *} */
targets,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.targets = targets;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Assign = function Assign(
/* {asdl_seq *} */
targets,
/* {expr_ty}
*/
value,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.targets = targets;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.AugAssign = function AugAssign(
/* {expr_ty} */
target,
/*
{operator_ty} */
op,
/*
{expr_ty} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.target = target;
  this.op = op;
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.AnnAssign = function AnnAssign(
/* {expr_ty} */
target,
/* {expr_ty}
*/
annotation,
/* {expr_ty} */
value,
/* {int} */
simple,
/*
{int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.target = target;
  this.annotation = annotation;
  this.value = value;
  this.simple = simple;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.For = function For(
/* {expr_ty} */
target,
/* {expr_ty} */
iter,
/*
{asdl_seq *} */
body,
/* {asdl_seq *} */
orelse,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.target = target;
  this.iter = iter;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.AsyncFor = function AsyncFor(
/* {expr_ty} */
target,
/* {expr_ty}
*/
iter,
/* {asdl_seq *} */
body,
/* {asdl_seq *} */
orelse,
/*
{int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.target = target;
  this.iter = iter;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.While = function While(
/* {expr_ty} */
test,
/* {asdl_seq *} */
body,
/* {asdl_seq *} */
orelse,
/*
{int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.If = function If(
/* {expr_ty} */
test,
/* {asdl_seq *} */
body,
/*
{asdl_seq *} */
orelse,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.With = function With(
/* {asdl_seq *} */
items,
/* {asdl_seq *} */
body,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.items = items;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.AsyncWith = function AsyncWith(
/* {asdl_seq *} */
items,
/*
{asdl_seq *} */
body,
/* {int}
*/
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.items = items;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Raise = function Raise(
/* {expr_ty} */
exc,
/* {expr_ty} */
cause,
/* {expr_ty} */
inst,
/* {expr_ty} */
tback,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.exc = exc;
  this.cause = cause;
  this.inst = inst;
  this.tback = tback;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Try = function Try(
/* {asdl_seq *} */
body,
/* {asdl_seq *} */
handlers,
/* {asdl_seq *} */
orelse,
/*
{asdl_seq *} */
finalbody,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.body = body;
  this.handlers = handlers;
  this.orelse = orelse;
  this.finalbody = finalbody;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Assert = function Assert(
/* {expr_ty} */
test,
/* {expr_ty} */
msg,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.test = test;
  this.msg = msg;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Import = function Import(
/* {asdl_seq *} */
names,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.ImportFrom = function ImportFrom(
/* {identifier} */
module,
/*
{asdl_seq *} */
names,
/*
{int} */
level,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.module = module;
  this.names = names;
  this.level = level;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Global = function Global(
/* {asdl_seq *} */
names,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Nonlocal = function Nonlocal(
/* {asdl_seq *} */
names,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int}
*/
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.names = names;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Expr = function Expr(
/* {expr_ty} */
value,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Pass = function Pass(
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Break = function Break(
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Continue = function Continue(
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Print = function Print(
/* {expr_ty} */
dest,
/* {asdl_seq *} */
values,
/* {int} */
nl,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.dest = dest;
  this.values = values;
  this.nl = nl;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Debugger = function Debugger(
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.BoolOp = function BoolOp(
/* {boolop_ty} */
op,
/* {asdl_seq *} */
values,
/* {int} */
lineno,
/* {int}
*/
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.op = op;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.BinOp = function BinOp(
/* {expr_ty} */
left,
/* {operator_ty} */
op,
/* {expr_ty} */
right,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.left = left;
  this.op = op;
  this.right = right;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.UnaryOp = function UnaryOp(
/* {unaryop_ty} */
op,
/* {expr_ty} */
operand,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.op = op;
  this.operand = operand;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Lambda = function Lambda(
/* {arguments__ty} */
args,
/* {expr_ty}
*/
body,
/* {int} */
lineno,
/* {int}
*/
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.args = args;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.IfExp = function IfExp(
/* {expr_ty} */
test,
/* {expr_ty} */
body,
/* {expr_ty} */
orelse,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.test = test;
  this.body = body;
  this.orelse = orelse;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Dict = function Dict(
/* {asdl_seq *} */
keys,
/* {asdl_seq *} */
values,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.keys = keys;
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Set = function Set(
/* {asdl_seq *} */
elts,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elts = elts;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.ListComp = function ListComp(
/* {expr_ty} */
elt,
/* {asdl_seq *}
*/
generators,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int}
*/
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.SetComp = function SetComp(
/* {expr_ty} */
elt,
/* {asdl_seq *} */
generators,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.DictComp = function DictComp(
/* {expr_ty} */
key,
/* {expr_ty} */
value,
/* {asdl_seq *} */
generators,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int}
*/
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.key = key;
  this.value = value;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.GeneratorExp = function GeneratorExp(
/* {expr_ty} */
elt,
/*
{asdl_seq *} */
generators,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elt = elt;
  this.generators = generators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Await = function Await(
/* {expr_ty} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Yield = function Yield(
/* {expr_ty} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.YieldFrom = function YieldFrom(
/* {expr_ty} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Compare = function Compare(
/* {expr_ty} */
left,
/* {asdl_int_seq
*} */
ops,
/* {asdl_seq *} */
comparators,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.left = left;
  this.ops = ops;
  this.comparators = comparators;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Call = function Call(
/* {expr_ty} */
func,
/* {asdl_seq *} */
args,
/* {asdl_seq *} */
keywords,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int}
*/
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.func = func;
  this.args = args;
  this.keywords = keywords;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Num = function Num(
/* {object} */
n,
/* {int} */
lineno,
/* {int}
*/
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.n = n;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Str = function Str(
/* {string} */
s,
/* {int} */
lineno,
/* {int}
*/
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.s = s;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.FormattedValue = function FormattedValue(
/* {expr_ty} */
value,
/*
{int} */
conversion,
/* {expr_ty} */
format_spec,
/* {int}
*/
lineno,
/* {int}
*/
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.conversion = conversion;
  this.format_spec = format_spec;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.JoinedStr = function JoinedStr(
/* {asdl_seq *} */
values,
/* {int}
*/
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.values = values;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Bytes = function Bytes(
/* {bytes} */
s,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.s = s;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.NameConstant = function NameConstant(
/* {singleton} */
value,
/*
{int} */
lineno,
/* {int}
*/
col_offset,
/* {int}
*/
end_lineno,
/* {int}
*/
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Ellipsis = function Ellipsis(
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Constant = function Constant(
/* {constant} */
value,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int}
*/
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Attribute = function Attribute(
/* {expr_ty} */
value,
/*
{identifier} */
attr,
/*
{expr_context_ty} */
ctx,
/*
{int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.attr = attr;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Subscript = function Subscript(
/* {expr_ty} */
value,
/* {slice_ty}
*/
slice,
/* {expr_context_ty}
*/
ctx,
/* {int} */
lineno,
/*
{int} */
col_offset,
/* {int}
*/
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.slice = slice;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Starred = function Starred(
/* {expr_ty} */
value,
/*
{expr_context_ty} */
ctx,
/* {int}
*/
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.value = value;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Name = function Name(
/* {identifier} */
id,
/* {expr_context_ty} */
ctx,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.id = id;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.List = function List(
/* {asdl_seq *} */
elts,
/* {expr_context_ty}
*/
ctx,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/*
{int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Tuple = function Tuple(
/* {asdl_seq *} */
elts,
/*
{expr_context_ty} */
ctx,
/* {int} */
lineno,
/* {int} */
col_offset,
/*
{int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.elts = elts;
  this.ctx = ctx;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.Slice = function Slice(
/* {expr_ty} */
lower,
/* {expr_ty} */
upper,
/* {expr_ty} */
step) {
  this.lower = lower;
  this.upper = upper;
  this.step = step;
  return this;
};
/** @constructor */


Sk.astnodes.ExtSlice = function ExtSlice(
/* {asdl_seq *} */
dims) {
  this.dims = dims;
  return this;
};
/** @constructor */


Sk.astnodes.Index = function Index(
/* {expr_ty} */
value) {
  this.value = value;
  return this;
};
/** @constructor */


Sk.astnodes.comprehension = function comprehension(
/* {expr_ty} */
target,
/*
{expr_ty} */
iter,
/*
{asdl_seq *} */
ifs,
/*
{int} */
is_async) {
  this.target = target;
  this.iter = iter;
  this.ifs = ifs;
  this.is_async = is_async;
  return this;
};
/** @constructor */


Sk.astnodes.ExceptHandler = function ExceptHandler(
/* {expr_ty} */
type,
/*
{identifier} */
name,
/* {asdl_seq *} */
body,
/* {int} */
lineno,
/* {int} */
col_offset,
/* {int} */
end_lineno,
/* {int} */
end_col_offset) {
  Sk.asserts.assert(lineno !== null && lineno !== undefined);
  Sk.asserts.assert(col_offset !== null && col_offset !== undefined);
  Sk.asserts.assert(end_lineno !== null && end_lineno !== undefined);
  Sk.asserts.assert(end_col_offset !== null && end_col_offset !== undefined);
  this.type = type;
  this.name = name;
  this.body = body;
  this.lineno = lineno;
  this.col_offset = col_offset;
  this.end_lineno = end_lineno;
  this.end_col_offset = end_col_offset;
  return this;
};
/** @constructor */


Sk.astnodes.arguments_ = function arguments_(
/* {asdl_seq *} */
args,
/*
{arg_ty} */
vararg,
/*
{asdl_seq *} */
kwonlyargs,
/* {asdl_seq *} */
kw_defaults,
/* {arg_ty} */
kwarg,
/* {asdl_seq *} */
defaults) {
  this.args = args;
  this.vararg = vararg;
  this.kwonlyargs = kwonlyargs;
  this.kw_defaults = kw_defaults;
  this.kwarg = kwarg;
  this.defaults = defaults;
  return this;
};
/** @constructor */


Sk.astnodes.arg = function arg(
/* {identifier} */
arg,
/* {expr_ty} */
annotation) {
  this.arg = arg;
  this.annotation = annotation;
  return this;
};
/** @constructor */


Sk.astnodes.keyword = function keyword(
/* {identifier} */
arg,
/* {expr_ty} */
value) {
  this.arg = arg;
  this.value = value;
  return this;
};
/** @constructor */


Sk.astnodes.alias = function alias(
/* {identifier} */
name,
/* {identifier} */
asname) {
  this.name = name;
  this.asname = asname;
  return this;
};
/** @constructor */


Sk.astnodes.withitem = function withitem(
/* {expr_ty} */
context_expr,
/*
{expr_ty} */
optional_vars) {
  this.context_expr = context_expr;
  this.optional_vars = optional_vars;
  return this;
};

Sk.astnodes.Module.prototype._astname = "Module";
Sk.astnodes.Module.prototype._fields = ["body", function (n) {
  return n.body;
}, "docstring", function (n) {
  return n.docstring;
}];
Sk.astnodes.Interactive.prototype._astname = "Interactive";
Sk.astnodes.Interactive.prototype._fields = ["body", function (n) {
  return n.body;
}];
Sk.astnodes.Expression.prototype._astname = "Expression";
Sk.astnodes.Expression.prototype._fields = ["body", function (n) {
  return n.body;
}];
Sk.astnodes.Suite.prototype._astname = "Suite";
Sk.astnodes.Suite.prototype._fields = ["body", function (n) {
  return n.body;
}];
Sk.astnodes.FunctionDef.prototype._astname = "FunctionDef";
Sk.astnodes.FunctionDef.prototype._fields = ["name", function (n) {
  return n.name;
}, "args", function (n) {
  return n.args;
}, "body", function (n) {
  return n.body;
}, "decorator_list", function (n) {
  return n.decorator_list;
}, "returns", function (n) {
  return n.returns;
}, "docstring", function (n) {
  return n.docstring;
}];
Sk.astnodes.AsyncFunctionDef.prototype._astname = "AsyncFunctionDef";
Sk.astnodes.AsyncFunctionDef.prototype._fields = ["name", function (n) {
  return n.name;
}, "args", function (n) {
  return n.args;
}, "body", function (n) {
  return n.body;
}, "decorator_list", function (n) {
  return n.decorator_list;
}, "returns", function (n) {
  return n.returns;
}, "docstring", function (n) {
  return n.docstring;
}];
Sk.astnodes.ClassDef.prototype._astname = "ClassDef";
Sk.astnodes.ClassDef.prototype._fields = ["name", function (n) {
  return n.name;
}, "bases", function (n) {
  return n.bases;
}, "keywords", function (n) {
  return n.keywords;
}, "body", function (n) {
  return n.body;
}, "decorator_list", function (n) {
  return n.decorator_list;
}, "docstring", function (n) {
  return n.docstring;
}];
Sk.astnodes.Return.prototype._astname = "Return";
Sk.astnodes.Return.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Delete.prototype._astname = "Delete";
Sk.astnodes.Delete.prototype._fields = ["targets", function (n) {
  return n.targets;
}];
Sk.astnodes.Assign.prototype._astname = "Assign";
Sk.astnodes.Assign.prototype._fields = ["targets", function (n) {
  return n.targets;
}, "value", function (n) {
  return n.value;
}];
Sk.astnodes.AugAssign.prototype._astname = "AugAssign";
Sk.astnodes.AugAssign.prototype._fields = ["target", function (n) {
  return n.target;
}, "op", function (n) {
  return n.op;
}, "value", function (n) {
  return n.value;
}];
Sk.astnodes.AnnAssign.prototype._astname = "AnnAssign";
Sk.astnodes.AnnAssign.prototype._fields = ["target", function (n) {
  return n.target;
}, "annotation", function (n) {
  return n.annotation;
}, "value", function (n) {
  return n.value;
}, "simple", function (n) {
  return n.simple;
}];
Sk.astnodes.For.prototype._astname = "For";
Sk.astnodes.For.prototype._fields = ["target", function (n) {
  return n.target;
}, "iter", function (n) {
  return n.iter;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Sk.astnodes.AsyncFor.prototype._astname = "AsyncFor";
Sk.astnodes.AsyncFor.prototype._fields = ["target", function (n) {
  return n.target;
}, "iter", function (n) {
  return n.iter;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Sk.astnodes.While.prototype._astname = "While";
Sk.astnodes.While.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Sk.astnodes.If.prototype._astname = "If";
Sk.astnodes.If.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Sk.astnodes.With.prototype._astname = "With";
Sk.astnodes.With.prototype._fields = ["items", function (n) {
  return n.items;
}, "body", function (n) {
  return n.body;
}];
Sk.astnodes.AsyncWith.prototype._astname = "AsyncWith";
Sk.astnodes.AsyncWith.prototype._fields = ["items", function (n) {
  return n.items;
}, "body", function (n) {
  return n.body;
}];
Sk.astnodes.Raise.prototype._astname = "Raise";
Sk.astnodes.Raise.prototype._fields = ["exc", function (n) {
  return n.exc;
}, "cause", function (n) {
  return n.cause;
}, "inst", function (n) {
  return n.inst;
}, "tback", function (n) {
  return n.tback;
}];
Sk.astnodes.Try.prototype._astname = "Try";
Sk.astnodes.Try.prototype._fields = ["body", function (n) {
  return n.body;
}, "handlers", function (n) {
  return n.handlers;
}, "orelse", function (n) {
  return n.orelse;
}, "finalbody", function (n) {
  return n.finalbody;
}];
Sk.astnodes.Assert.prototype._astname = "Assert";
Sk.astnodes.Assert.prototype._fields = ["test", function (n) {
  return n.test;
}, "msg", function (n) {
  return n.msg;
}];
Sk.astnodes.Import.prototype._astname = "Import";
Sk.astnodes.Import.prototype._fields = ["names", function (n) {
  return n.names;
}];
Sk.astnodes.ImportFrom.prototype._astname = "ImportFrom";
Sk.astnodes.ImportFrom.prototype._fields = ["module", function (n) {
  return n.module;
}, "names", function (n) {
  return n.names;
}, "level", function (n) {
  return n.level;
}];
Sk.astnodes.Global.prototype._astname = "Global";
Sk.astnodes.Global.prototype._fields = ["names", function (n) {
  return n.names;
}];
Sk.astnodes.Nonlocal.prototype._astname = "Nonlocal";
Sk.astnodes.Nonlocal.prototype._fields = ["names", function (n) {
  return n.names;
}];
Sk.astnodes.Expr.prototype._astname = "Expr";
Sk.astnodes.Expr.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Pass.prototype._astname = "Pass";
Sk.astnodes.Pass.prototype._fields = [];
Sk.astnodes.Break.prototype._astname = "Break";
Sk.astnodes.Break.prototype._fields = [];
Sk.astnodes.Continue.prototype._astname = "Continue";
Sk.astnodes.Continue.prototype._fields = [];
Sk.astnodes.Print.prototype._astname = "Print";
Sk.astnodes.Print.prototype._fields = ["dest", function (n) {
  return n.dest;
}, "values", function (n) {
  return n.values;
}, "nl", function (n) {
  return n.nl;
}];
Sk.astnodes.Debugger.prototype._astname = "Debugger";
Sk.astnodes.Debugger.prototype._fields = [];
Sk.astnodes.BoolOp.prototype._astname = "BoolOp";
Sk.astnodes.BoolOp.prototype._fields = ["op", function (n) {
  return n.op;
}, "values", function (n) {
  return n.values;
}];
Sk.astnodes.BinOp.prototype._astname = "BinOp";
Sk.astnodes.BinOp.prototype._fields = ["left", function (n) {
  return n.left;
}, "op", function (n) {
  return n.op;
}, "right", function (n) {
  return n.right;
}];
Sk.astnodes.UnaryOp.prototype._astname = "UnaryOp";
Sk.astnodes.UnaryOp.prototype._fields = ["op", function (n) {
  return n.op;
}, "operand", function (n) {
  return n.operand;
}];
Sk.astnodes.Lambda.prototype._astname = "Lambda";
Sk.astnodes.Lambda.prototype._fields = ["args", function (n) {
  return n.args;
}, "body", function (n) {
  return n.body;
}];
Sk.astnodes.IfExp.prototype._astname = "IfExp";
Sk.astnodes.IfExp.prototype._fields = ["test", function (n) {
  return n.test;
}, "body", function (n) {
  return n.body;
}, "orelse", function (n) {
  return n.orelse;
}];
Sk.astnodes.Dict.prototype._astname = "Dict";
Sk.astnodes.Dict.prototype._fields = ["keys", function (n) {
  return n.keys;
}, "values", function (n) {
  return n.values;
}];
Sk.astnodes.Set.prototype._astname = "Set";
Sk.astnodes.Set.prototype._fields = ["elts", function (n) {
  return n.elts;
}];
Sk.astnodes.ListComp.prototype._astname = "ListComp";
Sk.astnodes.ListComp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
Sk.astnodes.SetComp.prototype._astname = "SetComp";
Sk.astnodes.SetComp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
Sk.astnodes.DictComp.prototype._astname = "DictComp";
Sk.astnodes.DictComp.prototype._fields = ["key", function (n) {
  return n.key;
}, "value", function (n) {
  return n.value;
}, "generators", function (n) {
  return n.generators;
}];
Sk.astnodes.GeneratorExp.prototype._astname = "GeneratorExp";
Sk.astnodes.GeneratorExp.prototype._fields = ["elt", function (n) {
  return n.elt;
}, "generators", function (n) {
  return n.generators;
}];
Sk.astnodes.Await.prototype._astname = "Await";
Sk.astnodes.Await.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Yield.prototype._astname = "Yield";
Sk.astnodes.Yield.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.YieldFrom.prototype._astname = "YieldFrom";
Sk.astnodes.YieldFrom.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Compare.prototype._astname = "Compare";
Sk.astnodes.Compare.prototype._fields = ["left", function (n) {
  return n.left;
}, "ops", function (n) {
  return n.ops;
}, "comparators", function (n) {
  return n.comparators;
}];
Sk.astnodes.Call.prototype._astname = "Call";
Sk.astnodes.Call.prototype._fields = ["func", function (n) {
  return n.func;
}, "args", function (n) {
  return n.args;
}, "keywords", function (n) {
  return n.keywords;
}];
Sk.astnodes.Num.prototype._astname = "Num";
Sk.astnodes.Num.prototype._fields = ["n", function (n) {
  return n.n;
}];
Sk.astnodes.Str.prototype._astname = "Str";
Sk.astnodes.Str.prototype._fields = ["s", function (n) {
  return n.s;
}];
Sk.astnodes.FormattedValue.prototype._astname = "FormattedValue";
Sk.astnodes.FormattedValue.prototype._fields = ["value", function (n) {
  return n.value;
}, "conversion", function (n) {
  return n.conversion;
}, "format_spec", function (n) {
  return n.format_spec;
}];
Sk.astnodes.JoinedStr.prototype._astname = "JoinedStr";
Sk.astnodes.JoinedStr.prototype._fields = ["values", function (n) {
  return n.values;
}];
Sk.astnodes.Bytes.prototype._astname = "Bytes";
Sk.astnodes.Bytes.prototype._fields = ["s", function (n) {
  return n.s;
}];
Sk.astnodes.NameConstant.prototype._astname = "NameConstant";
Sk.astnodes.NameConstant.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Ellipsis.prototype._astname = "Ellipsis";
Sk.astnodes.Ellipsis.prototype._fields = [];
Sk.astnodes.Constant.prototype._astname = "Constant";
Sk.astnodes.Constant.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.Attribute.prototype._astname = "Attribute";
Sk.astnodes.Attribute.prototype._fields = ["value", function (n) {
  return n.value;
}, "attr", function (n) {
  return n.attr;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.Subscript.prototype._astname = "Subscript";
Sk.astnodes.Subscript.prototype._fields = ["value", function (n) {
  return n.value;
}, "slice", function (n) {
  return n.slice;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.Starred.prototype._astname = "Starred";
Sk.astnodes.Starred.prototype._fields = ["value", function (n) {
  return n.value;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.Name.prototype._astname = "Name";
Sk.astnodes.Name.prototype._fields = ["id", function (n) {
  return n.id;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.List.prototype._astname = "List";
Sk.astnodes.List.prototype._fields = ["elts", function (n) {
  return n.elts;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.Tuple.prototype._astname = "Tuple";
Sk.astnodes.Tuple.prototype._fields = ["elts", function (n) {
  return n.elts;
}, "ctx", function (n) {
  return n.ctx;
}];
Sk.astnodes.Load.prototype._astname = "Load";
Sk.astnodes.Load.prototype._isenum = true;
Sk.astnodes.Store.prototype._astname = "Store";
Sk.astnodes.Store.prototype._isenum = true;
Sk.astnodes.Del.prototype._astname = "Del";
Sk.astnodes.Del.prototype._isenum = true;
Sk.astnodes.AugLoad.prototype._astname = "AugLoad";
Sk.astnodes.AugLoad.prototype._isenum = true;
Sk.astnodes.AugStore.prototype._astname = "AugStore";
Sk.astnodes.AugStore.prototype._isenum = true;
Sk.astnodes.Param.prototype._astname = "Param";
Sk.astnodes.Param.prototype._isenum = true;
Sk.astnodes.Slice.prototype._astname = "Slice";
Sk.astnodes.Slice.prototype._fields = ["lower", function (n) {
  return n.lower;
}, "upper", function (n) {
  return n.upper;
}, "step", function (n) {
  return n.step;
}];
Sk.astnodes.ExtSlice.prototype._astname = "ExtSlice";
Sk.astnodes.ExtSlice.prototype._fields = ["dims", function (n) {
  return n.dims;
}];
Sk.astnodes.Index.prototype._astname = "Index";
Sk.astnodes.Index.prototype._fields = ["value", function (n) {
  return n.value;
}];
Sk.astnodes.And.prototype._astname = "And";
Sk.astnodes.And.prototype._isenum = true;
Sk.astnodes.Or.prototype._astname = "Or";
Sk.astnodes.Or.prototype._isenum = true;
Sk.astnodes.Add.prototype._astname = "Add";
Sk.astnodes.Add.prototype._isenum = true;
Sk.astnodes.Sub.prototype._astname = "Sub";
Sk.astnodes.Sub.prototype._isenum = true;
Sk.astnodes.Mult.prototype._astname = "Mult";
Sk.astnodes.Mult.prototype._isenum = true;
Sk.astnodes.MatMult.prototype._astname = "MatMult";
Sk.astnodes.MatMult.prototype._isenum = true;
Sk.astnodes.Div.prototype._astname = "Div";
Sk.astnodes.Div.prototype._isenum = true;
Sk.astnodes.Mod.prototype._astname = "Mod";
Sk.astnodes.Mod.prototype._isenum = true;
Sk.astnodes.Pow.prototype._astname = "Pow";
Sk.astnodes.Pow.prototype._isenum = true;
Sk.astnodes.LShift.prototype._astname = "LShift";
Sk.astnodes.LShift.prototype._isenum = true;
Sk.astnodes.RShift.prototype._astname = "RShift";
Sk.astnodes.RShift.prototype._isenum = true;
Sk.astnodes.BitOr.prototype._astname = "BitOr";
Sk.astnodes.BitOr.prototype._isenum = true;
Sk.astnodes.BitXor.prototype._astname = "BitXor";
Sk.astnodes.BitXor.prototype._isenum = true;
Sk.astnodes.BitAnd.prototype._astname = "BitAnd";
Sk.astnodes.BitAnd.prototype._isenum = true;
Sk.astnodes.FloorDiv.prototype._astname = "FloorDiv";
Sk.astnodes.FloorDiv.prototype._isenum = true;
Sk.astnodes.Invert.prototype._astname = "Invert";
Sk.astnodes.Invert.prototype._isenum = true;
Sk.astnodes.Not.prototype._astname = "Not";
Sk.astnodes.Not.prototype._isenum = true;
Sk.astnodes.UAdd.prototype._astname = "UAdd";
Sk.astnodes.UAdd.prototype._isenum = true;
Sk.astnodes.USub.prototype._astname = "USub";
Sk.astnodes.USub.prototype._isenum = true;
Sk.astnodes.Eq.prototype._astname = "Eq";
Sk.astnodes.Eq.prototype._isenum = true;
Sk.astnodes.NotEq.prototype._astname = "NotEq";
Sk.astnodes.NotEq.prototype._isenum = true;
Sk.astnodes.Lt.prototype._astname = "Lt";
Sk.astnodes.Lt.prototype._isenum = true;
Sk.astnodes.LtE.prototype._astname = "LtE";
Sk.astnodes.LtE.prototype._isenum = true;
Sk.astnodes.Gt.prototype._astname = "Gt";
Sk.astnodes.Gt.prototype._isenum = true;
Sk.astnodes.GtE.prototype._astname = "GtE";
Sk.astnodes.GtE.prototype._isenum = true;
Sk.astnodes.Is.prototype._astname = "Is";
Sk.astnodes.Is.prototype._isenum = true;
Sk.astnodes.IsNot.prototype._astname = "IsNot";
Sk.astnodes.IsNot.prototype._isenum = true;
Sk.astnodes.In.prototype._astname = "In";
Sk.astnodes.In.prototype._isenum = true;
Sk.astnodes.NotIn.prototype._astname = "NotIn";
Sk.astnodes.NotIn.prototype._isenum = true;
Sk.astnodes.comprehension.prototype._astname = "comprehension";
Sk.astnodes.comprehension.prototype._fields = ["target", function (n) {
  return n.target;
}, "iter", function (n) {
  return n.iter;
}, "ifs", function (n) {
  return n.ifs;
}, "is_async", function (n) {
  return n.is_async;
}];
Sk.astnodes.ExceptHandler.prototype._astname = "ExceptHandler";
Sk.astnodes.ExceptHandler.prototype._fields = ["type", function (n) {
  return n.type;
}, "name", function (n) {
  return n.name;
}, "body", function (n) {
  return n.body;
}];
Sk.astnodes.arguments_.prototype._astname = "arguments";
Sk.astnodes.arguments_.prototype._fields = ["args", function (n) {
  return n.args;
}, "vararg", function (n) {
  return n.vararg;
}, "kwonlyargs", function (n) {
  return n.kwonlyargs;
}, "kw_defaults", function (n) {
  return n.kw_defaults;
}, "kwarg", function (n) {
  return n.kwarg;
}, "defaults", function (n) {
  return n.defaults;
}];
Sk.astnodes.arg.prototype._astname = "arg";
Sk.astnodes.arg.prototype._fields = ["arg", function (n) {
  return n.arg;
}, "annotation", function (n) {
  return n.annotation;
}];
Sk.astnodes.keyword.prototype._astname = "keyword";
Sk.astnodes.keyword.prototype._fields = ["arg", function (n) {
  return n.arg;
}, "value", function (n) {
  return n.value;
}];
Sk.astnodes.alias.prototype._astname = "alias";
Sk.astnodes.alias.prototype._fields = ["name", function (n) {
  return n.name;
}, "asname", function (n) {
  return n.asname;
}];
Sk.astnodes.withitem.prototype._astname = "withitem";
Sk.astnodes.withitem.prototype._fields = ["context_expr", function (n) {
  return n.context_expr;
}, "optional_vars", function (n) {
  return n.optional_vars;
}];
Sk.exportSymbol("Sk.astnodes", Sk.astnodes); //"""Token constants (from somewhere)."""

var __all__ = ["tok_name", "ISTERMINAL", "ISNONTERMINAL", "ISEOF"]; // #  This file is automatically generated; please don't muck it up!
// #
// #  To update the symbols in this file, 'cd' to the top directory of
// #  the python source tree after building the interpreter and run:
// #
// #    ./python Lib/token.py
// #--start constants--

var tokens = {
  T_ENDMARKER: 0,
  T_NAME: 1,
  T_NUMBER: 2,
  T_STRING: 3,
  T_NEWLINE: 4,
  T_INDENT: 5,
  T_DEDENT: 6,
  T_LPAR: 7,
  T_RPAR: 8,
  T_LSQB: 9,
  T_RSQB: 10,
  T_COLON: 11,
  T_COMMA: 12,
  T_SEMI: 13,
  T_PLUS: 14,
  T_MINUS: 15,
  T_STAR: 16,
  T_SLASH: 17,
  T_VBAR: 18,
  T_AMPER: 19,
  T_LESS: 20,
  T_GREATER: 21,
  T_EQUAL: 22,
  T_DOT: 23,
  T_PERCENT: 24,
  T_LBRACE: 25,
  T_RBRACE: 26,
  T_EQEQUAL: 27,
  T_NOTEQUAL: 28,
  T_LESSEQUAL: 29,
  T_GREATEREQUAL: 30,
  T_TILDE: 31,
  T_CIRCUMFLEX: 32,
  T_LEFTSHIFT: 33,
  T_RIGHTSHIFT: 34,
  T_DOUBLESTAR: 35,
  T_PLUSEQUAL: 36,
  T_MINEQUAL: 37,
  T_STAREQUAL: 38,
  T_SLASHEQUAL: 39,
  T_PERCENTEQUAL: 40,
  T_AMPEREQUAL: 41,
  T_VBAREQUAL: 42,
  T_CIRCUMFLEXEQUAL: 43,
  T_LEFTSHIFTEQUAL: 44,
  T_RIGHTSHIFTEQUAL: 45,
  T_DOUBLESTAREQUAL: 46,
  T_DOUBLESLASH: 47,
  T_DOUBLESLASHEQUAL: 48,
  T_AT: 49,
  T_ATEQUAL: 50,
  T_RARROW: 51,
  T_ELLIPSIS: 52,
  T_OP: 53,
  T_AWAIT: 54,
  T_ASYNC: 55,
  T_ERRORTOKEN: 56,
  //special cases
  T_NT_OFFSET: 256,
  T_N_TOKENS: 60,
  //taken from tokenize.py
  T_COMMENT: 57,
  T_NL: 58,
  T_ENCODING: 59
}; // #--end constants--

var EXACT_TOKEN_TYPES = {
  "!=": tokens.NOTEQUAL,
  "%": tokens.PERCENT,
  "%=": tokens.PERCENTEQUAL,
  "&": tokens.AMPER,
  "&=": tokens.AMPEREQUAL,
  "(": tokens.LPAR,
  ")": tokens.RPAR,
  "*": tokens.STAR,
  "**": tokens.DOUBLESTAR,
  "**=": tokens.DOUBLESTAREQUAL,
  "*=": tokens.STAREQUAL,
  "+": tokens.PLUS,
  "+=": tokens.PLUSEQUAL,
  ",": tokens.COMMA,
  "-": tokens.MINUS,
  "-=": tokens.MINEQUAL,
  "->": tokens.RARROW,
  ".": tokens.DOT,
  "...": tokens.ELLIPSIS,
  "/": tokens.SLASH,
  "//": tokens.DOUBLESLASH,
  "//=": tokens.DOUBLESLASHEQUAL,
  "/=": tokens.SLASHEQUAL,
  ":": tokens.COLON,
  ":=": tokens.COLONEQUAL,
  ";": tokens.SEMI,
  "<": tokens.LESS,
  "<<": tokens.LEFTSHIFT,
  "<<=": tokens.LEFTSHIFTEQUAL,
  "<=": tokens.LESSEQUAL,
  "=": tokens.EQUAL,
  "==": tokens.EQEQUAL,
  ">": tokens.GREATER,
  ">=": tokens.GREATEREQUAL,
  ">>": tokens.RIGHTSHIFT,
  ">>=": tokens.RIGHTSHIFTEQUAL,
  "@": tokens.AT,
  "@=": tokens.ATEQUAL,
  "[": tokens.LSQB,
  "]": tokens.RSQB,
  "^": tokens.CIRCUMFLEX,
  "^=": tokens.CIRCUMFLEXEQUAL,
  "{": tokens.LBRACE,
  "|": tokens.VBAR,
  "|=": tokens.VBAREQUAL,
  "}": tokens.RBRACE,
  "~": tokens.TILDE
};
var tok_name = {};

(function () {
  for (var i in tokens) {
    tok_name[tokens[i]] = i;
  }
})();

__all__.concat(Object.keys(tok_name).map(function (k) {
  return tok_name[k];
}));

function ISTERMINAL(x) {
  return x < tokens.T_NT_OFFSET;
}

function ISNONTERMINAL(x) {
  return x >= tokens.T_NT_OFFSET;
}

function ISEOF(x) {
  return x == tokens.T_ENDMARKER;
}

Sk.token = {};
Sk.token.tokens = tokens;
Sk.token.tok_name = tok_name;
Sk.token.EXACT_TOKEN_TYPES = EXACT_TOKEN_TYPES;
Sk.token.ISTERMINAL = ISTERMINAL;
Sk.token.ISNONTERMINAL = ISNONTERMINAL;
Sk.token.ISEOF = ISEOF;
Sk.exportSymbol("Sk.token", Sk.token);
Sk.exportSymbol("Sk.token.tokens", Sk.token.tokens);
Sk.exportSymbol("Sk.token.tok_name", Sk.token.tok_name);
Sk.exportSymbol("Sk.token.EXACT_TOKEN_TYPES");
Sk.exportSymbol("Sk.token.ISTERMINAL", Sk.token.ISTERMINAL);
Sk.exportSymbol("Sk.token.ISNONTERMINAL", Sk.token.ISNONTERMINAL);
Sk.exportSymbol("Sk.token.ISEOF", Sk.token.ISEOF); // generated by pgen/main.py

Sk.OpMap = {
  "(": Sk.token.tokens.T_LPAR,
  ")": Sk.token.tokens.T_RPAR,
  "[": Sk.token.tokens.T_LSQB,
  "]": Sk.token.tokens.T_RSQB,
  ":": Sk.token.tokens.T_COLON,
  ",": Sk.token.tokens.T_COMMA,
  ";": Sk.token.tokens.T_SEMI,
  "+": Sk.token.tokens.T_PLUS,
  "-": Sk.token.tokens.T_MINUS,
  "*": Sk.token.tokens.T_STAR,
  "/": Sk.token.tokens.T_SLASH,
  "|": Sk.token.tokens.T_VBAR,
  "&": Sk.token.tokens.T_AMPER,
  "<": Sk.token.tokens.T_LESS,
  ">": Sk.token.tokens.T_GREATER,
  "=": Sk.token.tokens.T_EQUAL,
  ".": Sk.token.tokens.T_DOT,
  "%": Sk.token.tokens.T_PERCENT,
  "`": Sk.token.tokens.T_BACKQUOTE,
  "{": Sk.token.tokens.T_LBRACE,
  "}": Sk.token.tokens.T_RBRACE,
  "@": Sk.token.tokens.T_AT,
  "==": Sk.token.tokens.T_EQEQUAL,
  "!=": Sk.token.tokens.T_NOTEQUAL,
  "<>": Sk.token.tokens.T_NOTEQUAL,
  "<=": Sk.token.tokens.T_LESSEQUAL,
  ">=": Sk.token.tokens.T_GREATEREQUAL,
  "~": Sk.token.tokens.T_TILDE,
  "^": Sk.token.tokens.T_CIRCUMFLEX,
  "<<": Sk.token.tokens.T_LEFTSHIFT,
  ">>": Sk.token.tokens.T_RIGHTSHIFT,
  "**": Sk.token.tokens.T_DOUBLESTAR,
  "+=": Sk.token.tokens.T_PLUSEQUAL,
  "-=": Sk.token.tokens.T_MINEQUAL,
  "*=": Sk.token.tokens.T_STAREQUAL,
  "/=": Sk.token.tokens.T_SLASHEQUAL,
  "%=": Sk.token.tokens.T_PERCENTEQUAL,
  "&=": Sk.token.tokens.T_AMPEREQUAL,
  "|=": Sk.token.tokens.T_VBAREQUAL,
  "^=": Sk.token.tokens.T_CIRCUMFLEXEQUAL,
  "<<=": Sk.token.tokens.T_LEFTSHIFTEQUAL,
  ">>=": Sk.token.tokens.T_RIGHTSHIFTEQUAL,
  "**=": Sk.token.tokens.T_DOUBLESTAREQUAL,
  "//": Sk.token.tokens.T_DOUBLESLASH,
  "//=": Sk.token.tokens.T_DOUBLESLASHEQUAL,
  "->": Sk.token.tokens.T_RARROW
};
Sk.ParseTables = {
  sym: {
    and_expr: 257,
    and_test: 258,
    annassign: 259,
    arglist: 260,
    argument: 261,
    arith_expr: 262,
    assert_stmt: 263,
    async_funcdef: 264,
    async_stmt: 265,
    atom: 266,
    atom_expr: 267,
    augassign: 268,
    break_stmt: 269,
    classdef: 270,
    comp_for: 271,
    comp_if: 272,
    comp_iter: 273,
    comp_op: 274,
    comparison: 275,
    compound_stmt: 276,
    continue_stmt: 277,
    debugger_stmt: 278,
    decorated: 279,
    decorator: 280,
    decorators: 281,
    del_stmt: 282,
    dictorsetmaker: 283,
    dotted_as_name: 284,
    dotted_as_names: 285,
    dotted_name: 286,
    encoding_decl: 287,
    eval_input: 288,
    except_clause: 289,
    expr: 290,
    expr_stmt: 291,
    exprlist: 292,
    factor: 293,
    file_input: 294,
    flow_stmt: 295,
    for_stmt: 296,
    funcdef: 297,
    global_stmt: 298,
    if_stmt: 299,
    import_as_name: 300,
    import_as_names: 301,
    import_from: 302,
    import_name: 303,
    import_stmt: 304,
    lambdef: 305,
    lambdef_nocond: 306,
    nonlocal_stmt: 307,
    not_test: 308,
    or_test: 309,
    parameters: 310,
    pass_stmt: 311,
    power: 312,
    print_stmt: 313,
    raise_stmt: 314,
    return_stmt: 315,
    shift_expr: 316,
    simple_stmt: 317,
    single_input: 256,
    sliceop: 318,
    small_stmt: 319,
    star_expr: 320,
    stmt: 321,
    subscript: 322,
    subscriptlist: 323,
    suite: 324,
    term: 325,
    test: 326,
    test_nocond: 327,
    testlist: 328,
    testlist_comp: 329,
    testlist_star_expr: 330,
    tfpdef: 331,
    trailer: 332,
    try_stmt: 333,
    typedargslist: 334,
    varargslist: 335,
    vfpdef: 336,
    while_stmt: 337,
    with_item: 338,
    with_stmt: 339,
    xor_expr: 340,
    yield_arg: 341,
    yield_expr: 342,
    yield_stmt: 343
  },
  number2symbol: {
    256: 'single_input',
    257: 'and_expr',
    258: 'and_test',
    259: 'annassign',
    260: 'arglist',
    261: 'argument',
    262: 'arith_expr',
    263: 'assert_stmt',
    264: 'async_funcdef',
    265: 'async_stmt',
    266: 'atom',
    267: 'atom_expr',
    268: 'augassign',
    269: 'break_stmt',
    270: 'classdef',
    271: 'comp_for',
    272: 'comp_if',
    273: 'comp_iter',
    274: 'comp_op',
    275: 'comparison',
    276: 'compound_stmt',
    277: 'continue_stmt',
    278: 'debugger_stmt',
    279: 'decorated',
    280: 'decorator',
    281: 'decorators',
    282: 'del_stmt',
    283: 'dictorsetmaker',
    284: 'dotted_as_name',
    285: 'dotted_as_names',
    286: 'dotted_name',
    287: 'encoding_decl',
    288: 'eval_input',
    289: 'except_clause',
    290: 'expr',
    291: 'expr_stmt',
    292: 'exprlist',
    293: 'factor',
    294: 'file_input',
    295: 'flow_stmt',
    296: 'for_stmt',
    297: 'funcdef',
    298: 'global_stmt',
    299: 'if_stmt',
    300: 'import_as_name',
    301: 'import_as_names',
    302: 'import_from',
    303: 'import_name',
    304: 'import_stmt',
    305: 'lambdef',
    306: 'lambdef_nocond',
    307: 'nonlocal_stmt',
    308: 'not_test',
    309: 'or_test',
    310: 'parameters',
    311: 'pass_stmt',
    312: 'power',
    313: 'print_stmt',
    314: 'raise_stmt',
    315: 'return_stmt',
    316: 'shift_expr',
    317: 'simple_stmt',
    318: 'sliceop',
    319: 'small_stmt',
    320: 'star_expr',
    321: 'stmt',
    322: 'subscript',
    323: 'subscriptlist',
    324: 'suite',
    325: 'term',
    326: 'test',
    327: 'test_nocond',
    328: 'testlist',
    329: 'testlist_comp',
    330: 'testlist_star_expr',
    331: 'tfpdef',
    332: 'trailer',
    333: 'try_stmt',
    334: 'typedargslist',
    335: 'varargslist',
    336: 'vfpdef',
    337: 'while_stmt',
    338: 'with_item',
    339: 'with_stmt',
    340: 'xor_expr',
    341: 'yield_arg',
    342: 'yield_expr',
    343: 'yield_stmt'
  },
  dfas: {
    256: [[[[1, 1], [2, 2], [3, 1]], [[0, 1]], [[3, 1]]], {
      3: 1,
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1,
      43: 1
    }],
    257: [[[[44, 1]], [[45, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    258: [[[[46, 1]], [[47, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    259: [[[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]], {
      48: 1
    }],
    260: [[[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1,
      53: 1
    }],
    261: [[[[10, 1], [53, 1], [49, 2]], [[49, 3]], [[50, 1], [54, 3], [0, 2]], [[0, 3]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1,
      53: 1
    }],
    262: [[[[55, 1]], [[26, 0], [19, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    263: [[[[37, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]], {
      37: 1
    }],
    264: [[[[18, 1]], [[56, 2]], [[0, 2]]], {
      18: 1
    }],
    265: [[[[18, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]], {
      18: 1
    }],
    266: [[[[35, 1], [23, 2], [13, 2], [25, 3], [42, 5], [28, 2], [29, 4], [32, 2], [39, 2], [34, 2]], [[35, 1], [0, 1]], [[0, 2]], [[59, 6], [60, 2], [61, 6]], [[62, 7], [63, 2]], [[59, 8], [64, 2]], [[60, 2]], [[63, 2]], [[64, 2]]], {
      13: 1,
      23: 1,
      25: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    267: [[[[15, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]], {
      13: 1,
      15: 1,
      23: 1,
      25: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    268: [[[[67, 1], [68, 1], [69, 1], [70, 1], [71, 1], [72, 1], [73, 1], [74, 1], [75, 1], [76, 1], [77, 1], [78, 1], [79, 1]], [[0, 1]]], {
      67: 1,
      68: 1,
      69: 1,
      70: 1,
      71: 1,
      72: 1,
      73: 1,
      74: 1,
      75: 1,
      76: 1,
      77: 1,
      78: 1,
      79: 1
    }],
    269: [[[[4, 1]], [[0, 1]]], {
      4: 1
    }],
    270: [[[[43, 1]], [[28, 2]], [[48, 4], [25, 3]], [[80, 5], [60, 6]], [[81, 7]], [[60, 6]], [[48, 4]], [[0, 7]]], {
      43: 1
    }],
    271: [[[[33, 2], [18, 1]], [[33, 2]], [[82, 3]], [[83, 4]], [[84, 5]], [[85, 6], [0, 5]], [[0, 6]]], {
      18: 1,
      33: 1
    }],
    272: [[[[7, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]], {
      7: 1
    }],
    273: [[[[87, 1], [54, 1]], [[0, 1]]], {
      7: 1,
      18: 1,
      33: 1
    }],
    274: [[[[88, 1], [89, 1], [90, 1], [91, 1], [30, 2], [83, 1], [92, 1], [92, 1], [93, 3], [94, 1]], [[0, 1]], [[83, 1]], [[30, 1], [0, 3]]], {
      30: 1,
      83: 1,
      88: 1,
      89: 1,
      90: 1,
      91: 1,
      92: 1,
      93: 1,
      94: 1
    }],
    275: [[[[95, 1]], [[96, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    276: [[[[97, 1], [57, 1], [98, 1], [99, 1], [56, 1], [100, 1], [101, 1], [58, 1], [102, 1]], [[0, 1]]], {
      5: 1,
      7: 1,
      9: 1,
      12: 1,
      18: 1,
      21: 1,
      31: 1,
      33: 1,
      43: 1
    }],
    277: [[[[14, 1]], [[0, 1]]], {
      14: 1
    }],
    278: [[[[24, 1]], [[0, 1]]], {
      24: 1
    }],
    279: [[[[103, 1]], [[100, 2], [104, 2], [56, 2]], [[0, 2]]], {
      5: 1
    }],
    280: [[[[5, 1]], [[105, 2]], [[3, 3], [25, 4]], [[0, 3]], [[80, 5], [60, 6]], [[60, 6]], [[3, 3]]], {
      5: 1
    }],
    281: [[[[106, 1]], [[106, 1], [0, 1]]], {
      5: 1
    }],
    282: [[[[16, 1]], [[82, 2]], [[0, 2]]], {
      16: 1
    }],
    283: [[[[53, 1], [107, 2], [49, 3]], [[95, 4]], [[52, 5], [54, 6], [0, 2]], [[52, 5], [48, 7], [54, 6], [0, 3]], [[52, 8], [54, 6], [0, 4]], [[107, 9], [49, 9], [0, 5]], [[0, 6]], [[49, 4]], [[53, 10], [49, 11], [0, 8]], [[52, 5], [0, 9]], [[95, 12]], [[48, 13]], [[52, 8], [0, 12]], [[49, 12]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1,
      53: 1
    }],
    284: [[[[105, 1]], [[108, 2], [0, 1]], [[28, 3]], [[0, 3]]], {
      28: 1
    }],
    285: [[[[109, 1]], [[52, 0], [0, 1]]], {
      28: 1
    }],
    286: [[[[28, 1]], [[110, 0], [0, 1]]], {
      28: 1
    }],
    287: [[[[28, 1]], [[0, 1]]], {
      28: 1
    }],
    288: [[[[111, 1]], [[3, 1], [112, 2]], [[0, 2]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    289: [[[[113, 1]], [[49, 2], [0, 1]], [[52, 3], [108, 3], [0, 2]], [[49, 4]], [[0, 4]]], {
      113: 1
    }],
    290: [[[[114, 1]], [[115, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    291: [[[[116, 1]], [[50, 2], [117, 3], [118, 4], [0, 1]], [[61, 5], [116, 5]], [[61, 4], [111, 4]], [[0, 4]], [[50, 2], [0, 5]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    292: [[[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    293: [[[[26, 1], [11, 1], [19, 1], [119, 2]], [[120, 2]], [[0, 2]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    294: [[[[3, 0], [121, 0], [112, 1]], [[0, 1]]], {
      3: 1,
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1,
      43: 1,
      112: 1
    }],
    295: [[[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]], {
      4: 1,
      8: 1,
      14: 1,
      20: 1,
      36: 1
    }],
    296: [[[[33, 1]], [[82, 2]], [[83, 3]], [[111, 4]], [[48, 5]], [[81, 6]], [[127, 7], [0, 6]], [[48, 8]], [[81, 9]], [[0, 9]]], {
      33: 1
    }],
    297: [[[[12, 1]], [[28, 2]], [[128, 3]], [[129, 4], [48, 5]], [[49, 6]], [[81, 7]], [[48, 5]], [[0, 7]]], {
      12: 1
    }],
    298: [[[[38, 1]], [[28, 2]], [[52, 1], [0, 2]]], {
      38: 1
    }],
    299: [[[[7, 1]], [[49, 2]], [[48, 3]], [[81, 4]], [[127, 5], [130, 1], [0, 4]], [[48, 6]], [[81, 7]], [[0, 7]]], {
      7: 1
    }],
    300: [[[[28, 1]], [[108, 2], [0, 1]], [[28, 3]], [[0, 3]]], {
      28: 1
    }],
    301: [[[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]], {
      28: 1
    }],
    302: [[[[17, 1]], [[105, 2], [110, 3], [39, 3]], [[27, 4]], [[105, 2], [27, 4], [39, 3], [110, 3]], [[10, 5], [25, 6], [132, 5]], [[0, 5]], [[132, 7]], [[60, 5]]], {
      17: 1
    }],
    303: [[[[27, 1]], [[133, 2]], [[0, 2]]], {
      27: 1
    }],
    304: [[[[134, 1], [135, 1]], [[0, 1]]], {
      17: 1,
      27: 1
    }],
    305: [[[[22, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]], {
      22: 1
    }],
    306: [[[[22, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]], {
      22: 1
    }],
    307: [[[[40, 1]], [[28, 2]], [[52, 1], [0, 2]]], {
      40: 1
    }],
    308: [[[[137, 1], [30, 2]], [[0, 1]], [[46, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    309: [[[[138, 1]], [[139, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    310: [[[[25, 1]], [[60, 2], [140, 3]], [[0, 2]], [[60, 2]]], {
      25: 1
    }],
    311: [[[[6, 1]], [[0, 1]]], {
      6: 1
    }],
    312: [[[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]], {
      13: 1,
      15: 1,
      23: 1,
      25: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    313: [[[[41, 1]], [[142, 2], [49, 3], [0, 1]], [[49, 4]], [[52, 5], [0, 3]], [[52, 6], [0, 4]], [[49, 3], [0, 5]], [[49, 7]], [[52, 8], [0, 7]], [[49, 7], [0, 8]]], {
      41: 1
    }],
    314: [[[[20, 1]], [[49, 2], [0, 1]], [[52, 3], [17, 3], [0, 2]], [[49, 4]], [[52, 5], [0, 4]], [[49, 6]], [[0, 6]]], {
      20: 1
    }],
    315: [[[[36, 1]], [[111, 2], [0, 1]], [[0, 2]]], {
      36: 1
    }],
    316: [[[[143, 1]], [[144, 0], [142, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    317: [[[[145, 1]], [[3, 2], [146, 3]], [[0, 2]], [[3, 2], [145, 1]]], {
      4: 1,
      6: 1,
      8: 1,
      10: 1,
      11: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      19: 1,
      20: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1
    }],
    318: [[[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]], {
      48: 1
    }],
    319: [[[[147, 1], [148, 1], [149, 1], [150, 1], [151, 1], [152, 1], [153, 1], [154, 1], [155, 1], [156, 1]], [[0, 1]]], {
      4: 1,
      6: 1,
      8: 1,
      10: 1,
      11: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      19: 1,
      20: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1
    }],
    320: [[[[10, 1]], [[95, 2]], [[0, 2]]], {
      10: 1
    }],
    321: [[[[1, 1], [2, 1]], [[0, 1]]], {
      4: 1,
      5: 1,
      6: 1,
      7: 1,
      8: 1,
      9: 1,
      10: 1,
      11: 1,
      12: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      18: 1,
      19: 1,
      20: 1,
      21: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      31: 1,
      32: 1,
      33: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1,
      43: 1
    }],
    322: [[[[48, 1], [49, 2]], [[157, 3], [49, 4], [0, 1]], [[48, 1], [0, 2]], [[0, 3]], [[157, 3], [0, 4]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1,
      48: 1
    }],
    323: [[[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1,
      48: 1
    }],
    324: [[[[3, 1], [1, 2]], [[159, 3]], [[0, 2]], [[121, 4]], [[160, 2], [121, 4]]], {
      3: 1,
      4: 1,
      6: 1,
      8: 1,
      10: 1,
      11: 1,
      13: 1,
      14: 1,
      15: 1,
      16: 1,
      17: 1,
      19: 1,
      20: 1,
      22: 1,
      23: 1,
      24: 1,
      25: 1,
      26: 1,
      27: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      36: 1,
      37: 1,
      38: 1,
      39: 1,
      40: 1,
      41: 1,
      42: 1
    }],
    325: [[[[120, 1]], [[5, 0], [10, 0], [161, 0], [162, 0], [163, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    326: [[[[84, 2], [164, 1]], [[0, 1]], [[7, 3], [0, 2]], [[84, 4]], [[127, 5]], [[49, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    327: [[[[165, 1], [84, 1]], [[0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    328: [[[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    329: [[[[107, 1], [49, 1]], [[52, 2], [54, 3], [0, 1]], [[107, 4], [49, 4], [0, 2]], [[0, 3]], [[52, 2], [0, 4]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    330: [[[[107, 1], [49, 1]], [[52, 2], [0, 1]], [[107, 1], [49, 1], [0, 2]]], {
      10: 1,
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    331: [[[[28, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]], {
      28: 1
    }],
    332: [[[[25, 1], [42, 3], [110, 2]], [[80, 4], [60, 5]], [[28, 5]], [[166, 6]], [[60, 5]], [[0, 5]], [[64, 5]]], {
      25: 1,
      42: 1,
      110: 1
    }],
    333: [[[[21, 1]], [[48, 2]], [[81, 3]], [[167, 4], [168, 5]], [[48, 6]], [[48, 7]], [[81, 8]], [[81, 9]], [[127, 10], [167, 4], [168, 5], [0, 8]], [[0, 9]], [[48, 11]], [[81, 12]], [[168, 5], [0, 12]]], {
      21: 1
    }],
    334: [[[[169, 1], [10, 2], [53, 3]], [[50, 4], [52, 5], [0, 1]], [[169, 6], [52, 7], [0, 2]], [[169, 8]], [[49, 9]], [[169, 1], [53, 3], [10, 10], [0, 5]], [[52, 7], [0, 6]], [[169, 11], [53, 3], [0, 7]], [[52, 12], [0, 8]], [[52, 5], [0, 9]], [[169, 13], [52, 14], [0, 10]], [[50, 15], [52, 7], [0, 11]], [[0, 12]], [[52, 14], [0, 13]], [[169, 16], [53, 3], [0, 14]], [[49, 6]], [[50, 17], [52, 14], [0, 16]], [[49, 13]]], {
      10: 1,
      28: 1,
      53: 1
    }],
    335: [[[[53, 1], [170, 2], [10, 3]], [[170, 4]], [[52, 5], [50, 6], [0, 2]], [[52, 7], [170, 8], [0, 3]], [[52, 9], [0, 4]], [[10, 10], [170, 2], [53, 1], [0, 5]], [[49, 11]], [[53, 1], [170, 12], [0, 7]], [[52, 7], [0, 8]], [[0, 9]], [[52, 13], [170, 14], [0, 10]], [[52, 5], [0, 11]], [[52, 7], [50, 15], [0, 12]], [[53, 1], [170, 16], [0, 13]], [[52, 13], [0, 14]], [[49, 8]], [[50, 17], [52, 13], [0, 16]], [[49, 14]]], {
      10: 1,
      28: 1,
      53: 1
    }],
    336: [[[[28, 1]], [[0, 1]]], {
      28: 1
    }],
    337: [[[[9, 1]], [[49, 2]], [[48, 3]], [[81, 4]], [[127, 5], [0, 4]], [[48, 6]], [[81, 7]], [[0, 7]]], {
      9: 1
    }],
    338: [[[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    339: [[[[31, 1]], [[171, 2]], [[52, 1], [48, 3]], [[81, 4]], [[0, 4]]], {
      31: 1
    }],
    340: [[[[172, 1]], [[173, 0], [0, 1]]], {
      11: 1,
      13: 1,
      15: 1,
      19: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    341: [[[[17, 1], [111, 2]], [[49, 2]], [[0, 2]]], {
      11: 1,
      13: 1,
      15: 1,
      17: 1,
      19: 1,
      22: 1,
      23: 1,
      25: 1,
      26: 1,
      28: 1,
      29: 1,
      30: 1,
      32: 1,
      34: 1,
      35: 1,
      39: 1,
      42: 1
    }],
    342: [[[[8, 1]], [[174, 2], [0, 1]], [[0, 2]]], {
      8: 1
    }],
    343: [[[[61, 1]], [[0, 1]]], {
      8: 1
    }]
  },
  states: [[[[1, 1], [2, 2], [3, 1]], [[0, 1]], [[3, 1]]], [[[44, 1]], [[45, 0], [0, 1]]], [[[46, 1]], [[47, 0], [0, 1]]], [[[48, 1]], [[49, 2]], [[50, 3], [0, 2]], [[49, 4]], [[0, 4]]], [[[51, 1]], [[52, 2], [0, 1]], [[51, 1], [0, 2]]], [[[10, 1], [53, 1], [49, 2]], [[49, 3]], [[50, 1], [54, 3], [0, 2]], [[0, 3]]], [[[55, 1]], [[26, 0], [19, 0], [0, 1]]], [[[37, 1]], [[49, 2]], [[52, 3], [0, 2]], [[49, 4]], [[0, 4]]], [[[18, 1]], [[56, 2]], [[0, 2]]], [[[18, 1]], [[57, 2], [56, 2], [58, 2]], [[0, 2]]], [[[35, 1], [23, 2], [13, 2], [25, 3], [42, 5], [28, 2], [29, 4], [32, 2], [39, 2], [34, 2]], [[35, 1], [0, 1]], [[0, 2]], [[59, 6], [60, 2], [61, 6]], [[62, 7], [63, 2]], [[59, 8], [64, 2]], [[60, 2]], [[63, 2]], [[64, 2]]], [[[15, 1], [65, 2]], [[65, 2]], [[66, 2], [0, 2]]], [[[67, 1], [68, 1], [69, 1], [70, 1], [71, 1], [72, 1], [73, 1], [74, 1], [75, 1], [76, 1], [77, 1], [78, 1], [79, 1]], [[0, 1]]], [[[4, 1]], [[0, 1]]], [[[43, 1]], [[28, 2]], [[48, 4], [25, 3]], [[80, 5], [60, 6]], [[81, 7]], [[60, 6]], [[48, 4]], [[0, 7]]], [[[33, 2], [18, 1]], [[33, 2]], [[82, 3]], [[83, 4]], [[84, 5]], [[85, 6], [0, 5]], [[0, 6]]], [[[7, 1]], [[86, 2]], [[85, 3], [0, 2]], [[0, 3]]], [[[87, 1], [54, 1]], [[0, 1]]], [[[88, 1], [89, 1], [90, 1], [91, 1], [30, 2], [83, 1], [92, 1], [92, 1], [93, 3], [94, 1]], [[0, 1]], [[83, 1]], [[30, 1], [0, 3]]], [[[95, 1]], [[96, 0], [0, 1]]], [[[97, 1], [57, 1], [98, 1], [99, 1], [56, 1], [100, 1], [101, 1], [58, 1], [102, 1]], [[0, 1]]], [[[14, 1]], [[0, 1]]], [[[24, 1]], [[0, 1]]], [[[103, 1]], [[100, 2], [104, 2], [56, 2]], [[0, 2]]], [[[5, 1]], [[105, 2]], [[3, 3], [25, 4]], [[0, 3]], [[80, 5], [60, 6]], [[60, 6]], [[3, 3]]], [[[106, 1]], [[106, 1], [0, 1]]], [[[16, 1]], [[82, 2]], [[0, 2]]], [[[53, 1], [107, 2], [49, 3]], [[95, 4]], [[52, 5], [54, 6], [0, 2]], [[52, 5], [48, 7], [54, 6], [0, 3]], [[52, 8], [54, 6], [0, 4]], [[107, 9], [49, 9], [0, 5]], [[0, 6]], [[49, 4]], [[53, 10], [49, 11], [0, 8]], [[52, 5], [0, 9]], [[95, 12]], [[48, 13]], [[52, 8], [0, 12]], [[49, 12]]], [[[105, 1]], [[108, 2], [0, 1]], [[28, 3]], [[0, 3]]], [[[109, 1]], [[52, 0], [0, 1]]], [[[28, 1]], [[110, 0], [0, 1]]], [[[28, 1]], [[0, 1]]], [[[111, 1]], [[3, 1], [112, 2]], [[0, 2]]], [[[113, 1]], [[49, 2], [0, 1]], [[52, 3], [108, 3], [0, 2]], [[49, 4]], [[0, 4]]], [[[114, 1]], [[115, 0], [0, 1]]], [[[116, 1]], [[50, 2], [117, 3], [118, 4], [0, 1]], [[61, 5], [116, 5]], [[61, 4], [111, 4]], [[0, 4]], [[50, 2], [0, 5]]], [[[95, 1], [107, 1]], [[52, 2], [0, 1]], [[95, 1], [107, 1], [0, 2]]], [[[26, 1], [11, 1], [19, 1], [119, 2]], [[120, 2]], [[0, 2]]], [[[3, 0], [121, 0], [112, 1]], [[0, 1]]], [[[122, 1], [123, 1], [124, 1], [125, 1], [126, 1]], [[0, 1]]], [[[33, 1]], [[82, 2]], [[83, 3]], [[111, 4]], [[48, 5]], [[81, 6]], [[127, 7], [0, 6]], [[48, 8]], [[81, 9]], [[0, 9]]], [[[12, 1]], [[28, 2]], [[128, 3]], [[129, 4], [48, 5]], [[49, 6]], [[81, 7]], [[48, 5]], [[0, 7]]], [[[38, 1]], [[28, 2]], [[52, 1], [0, 2]]], [[[7, 1]], [[49, 2]], [[48, 3]], [[81, 4]], [[127, 5], [130, 1], [0, 4]], [[48, 6]], [[81, 7]], [[0, 7]]], [[[28, 1]], [[108, 2], [0, 1]], [[28, 3]], [[0, 3]]], [[[131, 1]], [[52, 2], [0, 1]], [[131, 1], [0, 2]]], [[[17, 1]], [[105, 2], [110, 3], [39, 3]], [[27, 4]], [[105, 2], [27, 4], [39, 3], [110, 3]], [[10, 5], [25, 6], [132, 5]], [[0, 5]], [[132, 7]], [[60, 5]]], [[[27, 1]], [[133, 2]], [[0, 2]]], [[[134, 1], [135, 1]], [[0, 1]]], [[[22, 1]], [[48, 2], [136, 3]], [[49, 4]], [[48, 2]], [[0, 4]]], [[[22, 1]], [[48, 2], [136, 3]], [[86, 4]], [[48, 2]], [[0, 4]]], [[[40, 1]], [[28, 2]], [[52, 1], [0, 2]]], [[[137, 1], [30, 2]], [[0, 1]], [[46, 1]]], [[[138, 1]], [[139, 0], [0, 1]]], [[[25, 1]], [[60, 2], [140, 3]], [[0, 2]], [[60, 2]]], [[[6, 1]], [[0, 1]]], [[[141, 1]], [[53, 2], [0, 1]], [[120, 3]], [[0, 3]]], [[[41, 1]], [[142, 2], [49, 3], [0, 1]], [[49, 4]], [[52, 5], [0, 3]], [[52, 6], [0, 4]], [[49, 3], [0, 5]], [[49, 7]], [[52, 8], [0, 7]], [[49, 7], [0, 8]]], [[[20, 1]], [[49, 2], [0, 1]], [[52, 3], [17, 3], [0, 2]], [[49, 4]], [[52, 5], [0, 4]], [[49, 6]], [[0, 6]]], [[[36, 1]], [[111, 2], [0, 1]], [[0, 2]]], [[[143, 1]], [[144, 0], [142, 0], [0, 1]]], [[[145, 1]], [[3, 2], [146, 3]], [[0, 2]], [[3, 2], [145, 1]]], [[[48, 1]], [[49, 2], [0, 1]], [[0, 2]]], [[[147, 1], [148, 1], [149, 1], [150, 1], [151, 1], [152, 1], [153, 1], [154, 1], [155, 1], [156, 1]], [[0, 1]]], [[[10, 1]], [[95, 2]], [[0, 2]]], [[[1, 1], [2, 1]], [[0, 1]]], [[[48, 1], [49, 2]], [[157, 3], [49, 4], [0, 1]], [[48, 1], [0, 2]], [[0, 3]], [[157, 3], [0, 4]]], [[[158, 1]], [[52, 2], [0, 1]], [[158, 1], [0, 2]]], [[[3, 1], [1, 2]], [[159, 3]], [[0, 2]], [[121, 4]], [[160, 2], [121, 4]]], [[[120, 1]], [[5, 0], [10, 0], [161, 0], [162, 0], [163, 0], [0, 1]]], [[[84, 2], [164, 1]], [[0, 1]], [[7, 3], [0, 2]], [[84, 4]], [[127, 5]], [[49, 1]]], [[[165, 1], [84, 1]], [[0, 1]]], [[[49, 1]], [[52, 2], [0, 1]], [[49, 1], [0, 2]]], [[[107, 1], [49, 1]], [[52, 2], [54, 3], [0, 1]], [[107, 4], [49, 4], [0, 2]], [[0, 3]], [[52, 2], [0, 4]]], [[[107, 1], [49, 1]], [[52, 2], [0, 1]], [[107, 1], [49, 1], [0, 2]]], [[[28, 1]], [[48, 2], [0, 1]], [[49, 3]], [[0, 3]]], [[[25, 1], [42, 3], [110, 2]], [[80, 4], [60, 5]], [[28, 5]], [[166, 6]], [[60, 5]], [[0, 5]], [[64, 5]]], [[[21, 1]], [[48, 2]], [[81, 3]], [[167, 4], [168, 5]], [[48, 6]], [[48, 7]], [[81, 8]], [[81, 9]], [[127, 10], [167, 4], [168, 5], [0, 8]], [[0, 9]], [[48, 11]], [[81, 12]], [[168, 5], [0, 12]]], [[[169, 1], [10, 2], [53, 3]], [[50, 4], [52, 5], [0, 1]], [[169, 6], [52, 7], [0, 2]], [[169, 8]], [[49, 9]], [[169, 1], [53, 3], [10, 10], [0, 5]], [[52, 7], [0, 6]], [[169, 11], [53, 3], [0, 7]], [[52, 12], [0, 8]], [[52, 5], [0, 9]], [[169, 13], [52, 14], [0, 10]], [[50, 15], [52, 7], [0, 11]], [[0, 12]], [[52, 14], [0, 13]], [[169, 16], [53, 3], [0, 14]], [[49, 6]], [[50, 17], [52, 14], [0, 16]], [[49, 13]]], [[[53, 1], [170, 2], [10, 3]], [[170, 4]], [[52, 5], [50, 6], [0, 2]], [[52, 7], [170, 8], [0, 3]], [[52, 9], [0, 4]], [[10, 10], [170, 2], [53, 1], [0, 5]], [[49, 11]], [[53, 1], [170, 12], [0, 7]], [[52, 7], [0, 8]], [[0, 9]], [[52, 13], [170, 14], [0, 10]], [[52, 5], [0, 11]], [[52, 7], [50, 15], [0, 12]], [[53, 1], [170, 16], [0, 13]], [[52, 13], [0, 14]], [[49, 8]], [[50, 17], [52, 13], [0, 16]], [[49, 14]]], [[[28, 1]], [[0, 1]]], [[[9, 1]], [[49, 2]], [[48, 3]], [[81, 4]], [[127, 5], [0, 4]], [[48, 6]], [[81, 7]], [[0, 7]]], [[[49, 1]], [[108, 2], [0, 1]], [[95, 3]], [[0, 3]]], [[[31, 1]], [[171, 2]], [[52, 1], [48, 3]], [[81, 4]], [[0, 4]]], [[[172, 1]], [[173, 0], [0, 1]]], [[[17, 1], [111, 2]], [[49, 2]], [[0, 2]]], [[[8, 1]], [[174, 2], [0, 1]], [[0, 2]]], [[[61, 1]], [[0, 1]]]],
  labels: [[0, 'EMPTY'], [317, null], [276, null], [4, null], [1, 'break'], [49, null], [1, 'pass'], [1, 'if'], [1, 'yield'], [1, 'while'], [16, null], [31, null], [1, 'def'], [1, 'null'], [1, 'continue'], [54, null], [1, 'del'], [1, 'from'], [55, null], [14, null], [1, 'raise'], [1, 'try'], [1, 'lambda'], [1, 'False'], [1, 'debugger'], [7, null], [15, null], [1, 'import'], [1, null], [25, null], [1, 'not'], [1, 'with'], [1, 'True'], [1, 'for'], [2, null], [3, null], [1, 'return'], [1, 'assert'], [1, 'global'], [52, null], [1, 'nonlocal'], [1, 'print'], [9, null], [1, 'class'], [316, null], [19, null], [308, null], [1, 'and'], [11, null], [326, null], [22, null], [261, null], [12, null], [35, null], [271, null], [325, null], [297, null], [339, null], [296, null], [329, null], [8, null], [342, null], [283, null], [26, null], [10, null], [266, null], [332, null], [45, null], [40, null], [41, null], [44, null], [37, null], [39, null], [36, null], [43, null], [50, null], [46, null], [42, null], [38, null], [48, null], [260, null], [324, null], [292, null], [1, 'in'], [309, null], [273, null], [327, null], [272, null], [29, null], [30, null], [27, null], [20, null], [28, null], [1, 'is'], [21, null], [290, null], [274, null], [265, null], [333, null], [279, null], [270, null], [299, null], [337, null], [281, null], [264, null], [286, null], [280, null], [320, null], [1, 'as'], [284, null], [23, null], [328, null], [0, null], [1, 'except'], [340, null], [18, null], [330, null], [268, null], [259, null], [312, null], [293, null], [321, null], [315, null], [343, null], [269, null], [277, null], [314, null], [1, 'else'], [310, null], [51, null], [1, 'elif'], [300, null], [301, null], [285, null], [302, null], [303, null], [335, null], [275, null], [258, null], [1, 'or'], [334, null], [267, null], [34, null], [262, null], [33, null], [319, null], [13, null], [307, null], [291, null], [304, null], [263, null], [278, null], [298, null], [311, null], [282, null], [295, null], [313, null], [318, null], [322, null], [5, null], [6, null], [24, null], [47, null], [17, null], [305, null], [306, null], [323, null], [289, null], [1, 'finally'], [331, null], [336, null], [338, null], [257, null], [32, null], [341, null]],
  keywords: {
    'False': 23,
    'null': 13,
    'True': 32,
    'and': 47,
    'as': 108,
    'assert': 37,
    'break': 4,
    'class': 43,
    'continue': 14,
    'debugger': 24,
    'def': 12,
    'del': 16,
    'elif': 130,
    'else': 127,
    'except': 113,
    'finally': 168,
    'for': 33,
    'from': 17,
    'global': 38,
    'if': 7,
    'import': 27,
    'in': 83,
    'is': 93,
    'lambda': 22,
    'nonlocal': 40,
    'not': 30,
    'or': 139,
    'pass': 6,
    'print': 41,
    'raise': 20,
    'return': 36,
    'try': 21,
    'while': 9,
    'with': 31,
    'yield': 8
  },
  tokens: {
    0: 112,
    1: 28,
    2: 34,
    3: 35,
    4: 3,
    5: 159,
    6: 160,
    7: 25,
    8: 60,
    9: 42,
    10: 64,
    11: 48,
    12: 52,
    13: 146,
    14: 19,
    15: 26,
    16: 10,
    17: 163,
    18: 115,
    19: 45,
    20: 91,
    21: 94,
    22: 50,
    23: 110,
    24: 161,
    25: 29,
    26: 63,
    27: 90,
    28: 92,
    29: 88,
    30: 89,
    31: 11,
    32: 173,
    33: 144,
    34: 142,
    35: 53,
    36: 73,
    37: 71,
    38: 78,
    39: 72,
    40: 68,
    41: 69,
    42: 77,
    43: 74,
    44: 70,
    45: 67,
    46: 76,
    47: 162,
    48: 79,
    49: 5,
    50: 75,
    51: 129,
    52: 39,
    54: 15,
    55: 18
  },
  start: 256
};
var tokens = Sk.token.tokens;
var TokenError = Sk.builtin.SyntaxError;
var IndentationError = Sk.builtin.SyntaxError;
/**
 *
 * @constructor
 * @param {number} type
 * @param {string} string
 * @param {Array<number>} start
 * @param {Array<number>} end
 * @param {string} line
 */

function TokenInfo(type, string, start, end, line) {
  this.type = type;
  this.string = string;
  this.start = start;
  this.end = end;
  this.line = line;
}

TokenInfo.prototype.exact_type = function () {
  if (this.type == tokens.T_OP && this.string in Sk.token.EXACT_TOKEN_TYPES) {
    return Sk.token.EXACT_TOKEN_TYPES[this.string];
  } else {
    return this.type;
  }
};
/** @param {...*} x */


function group(x) {
  var args = Array.prototype.slice.call(arguments);
  return "(" + args.join("|") + ")";
}
/** @param {...*} x */


function any(x) {
  return group.apply(null, arguments) + "*";
}
/** @param {...*} x */


function maybe(x) {
  return group.apply(null, arguments) + "?";
}

var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

function regexEscape(string) {
  return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
}
/**
 * Iterable contains
 * @template T
 * @param {Iterable<T>} a
 * @param {T} obj
 */


function contains(a, obj) {
  var i = a.length;

  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }

  return false;
}

function rstrip(input, what) {
  var i;

  for (i = input.length; i > 0; --i) {
    if (what.indexOf(input.charAt(i - 1)) === -1) {
      break;
    }
  }

  return input.substring(0, i);
}

var the_underscore = '_';
var Lu = '[A-Z]';
var Ll = '[a-z]';
var Lt = "[\\u{10B99}-\\u{10B9C}\\u{112A9}\\u{115DC}-\\u{115DD}\\u034F\\u115F-\\u1160\\u17B4-\\u17B5\\u2065\\u3164\\uFFA0\\uFFF0-\\uFFF8\\u{E0000}\\u{E0002}-\\u{E001F}\\u{E0080}-\\u{E00FF}\\u{E01F0}-\\u{E0FFF}\\u{112A9}\\u00D7]";
var Lm = "[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u06E5-\\u06E6\\u07F4-\\u07F5\\u0971\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1DFD-\\u1DFF\\u2E2F\\u30FC\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA788\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F\\u{16F93}-\\u{16F9F}\\u02D0-\\u02D1\\u0640\\u07FA\\u0E46\\u0EC6\\u1843\\u1AA7\\u1C7B\\u3005\\u3031-\\u3035\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA60C\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uFF70\\u{16B42}-\\u{16B43}\\u{16FE0}-\\u{16FE1}\\u02B0-\\u02B8\\u02C0-\\u02C1\\u02E0-\\u02E4\\u037A\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\uA69C-\\uA69D\\uA770\\uA7F8-\\uA7F9\\uAB5C-\\uAB5F\\uFF9E-\\uFF9F\\u02B2\\u1D62\\u1DA4\\u1DA8\\u2071\\u2C7C\\u2E18-\\u2E19\\u2E2F]";
var Lo = "[\\u2135-\\u2138\\u{1EE00}-\\u{1EE03}\\u{1EE05}-\\u{1EE1F}\\u{1EE21}-\\u{1EE22}\\u{1EE24}\\u{1EE27}\\u{1EE29}-\\u{1EE32}\\u{1EE34}-\\u{1EE37}\\u{1EE39}\\u{1EE3B}\\u{1EE42}\\u{1EE47}\\u{1EE49}\\u{1EE4B}\\u{1EE4D}-\\u{1EE4F}\\u{1EE51}-\\u{1EE52}\\u{1EE54}\\u{1EE57}\\u{1EE59}\\u{1EE5B}\\u{1EE5D}\\u{1EE5F}\\u{1EE61}-\\u{1EE62}\\u{1EE64}\\u{1EE67}-\\u{1EE6A}\\u{1EE6C}-\\u{1EE72}\\u{1EE74}-\\u{1EE77}\\u{1EE79}-\\u{1EE7C}\\u{1EE7E}\\u{1EE80}-\\u{1EE89}\\u{1EE8B}-\\u{1EE9B}\\u{1EEA1}-\\u{1EEA3}\\u{1EEA5}-\\u{1EEA9}\\u{1EEAB}-\\u{1EEBB}\\u3006\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uF900-\\uFA6D\\uFA70-\\uFAD9\\u{17000}-\\u{187F1}\\u{18800}-\\u{18AF2}\\u{1B170}-\\u{1B2FB}\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u{2F800}-\\u{2FA1D}\\uAAC0\\uAAC2\\uFE20-\\uFE2F\\u{10D22}-\\u{10D23}\\u{1135D}\\u00AA\\u00BA\\u3400-\\u4DB5\\u4E00-\\u9FEF\\uFA0E-\\uFA0F\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29\\u{20000}-\\u{2A6D6}\\u{2A700}-\\u{2B734}\\u{2B740}-\\u{2B81D}\\u{2B820}-\\u{2CEA1}\\u{2CEB0}-\\u{2EBE0}\\u115F-\\u1160\\u3164\\uFFA0\\u0673\\u17A3-\\u17A4\\u0E40-\\u0E44\\u0EC0-\\u0EC4\\u19B5-\\u19B7\\u19BA\\uAAB5-\\uAAB6\\uAAB9\\uAABB-\\uAABC]";
var Nl = "[\\u3007\\u3021-\\u3029\\u3038-\\u303A\\u2170-\\u217F\\u2160-\\u216F]";
var Mn = "[\\u104A-\\u104B\\u102B-\\u102C\\u102D-\\u1030\\u1031\\u1032-\\u1036\\u1038\\u103B-\\u103C\\u103D-\\u103E\\u1056-\\u1057\\u1058-\\u1059\\u105E-\\u1060\\u1062\\u1067-\\u1068\\u1071-\\u1074\\u1082\\u1083-\\u1084\\u1085-\\u1086\\u109C\\u109D\\u1037\\u1039-\\u103A\\u1087-\\u108C\\u108D\\u108F\\u109A-\\u109B\\uA9E5\\uAA7B\\uAA7C\\uAA7D\\uA9E6\\uAA70\\u104A-\\u104B]";
var Mc = "[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062\\u1067-\\u1068\\u1083-\\u1084\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CF2-\\u1CF3\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9BF\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\u{11000}\\u{11002}\\u{11082}\\u{110B0}-\\u{110B2}\\u{110B7}-\\u{110B8}\\u{1112C}\\u{11145}-\\u{11146}\\u{11182}\\u{111B3}-\\u{111B5}\\u{111BF}\\u{1122C}-\\u{1122E}\\u{11232}-\\u{11233}\\u{112E0}-\\u{112E2}\\u{11302}-\\u{11303}\\u{1133E}-\\u{1133F}\\u{11341}-\\u{11344}\\u{11347}-\\u{11348}\\u{1134B}-\\u{1134C}\\u{11357}\\u{11362}-\\u{11363}\\u{11435}-\\u{11437}\\u{11440}-\\u{11441}\\u{11445}\\u{114B0}-\\u{114B2}\\u{114B9}\\u{114BB}-\\u{114BE}\\u{114C1}\\u{115AF}-\\u{115B1}\\u{115B8}-\\u{115BB}\\u{115BE}\\u{11630}-\\u{11632}\\u{1163B}-\\u{1163C}\\u{1163E}\\u{116AC}\\u{116AE}-\\u{116AF}\\u{11720}-\\u{11721}\\u{11726}\\u{1182C}-\\u{1182E}\\u{11838}\\u{11A39}\\u{11A57}-\\u{11A58}\\u{11A97}\\u{11C2F}\\u{11C3E}\\u{11CA9}\\u{11CB1}\\u{11CB4}\\u{11D8A}-\\u{11D8E}\\u{11D93}-\\u{11D94}\\u{11D96}\\u{11EF5}-\\u{11EF6}\\u{16F51}-\\u{16F7E}\\u0F3E-\\u0F3F\\u1087-\\u108C\\u108F\\u109A-\\u109B\\u1B44\\u1BAA\\u1CE1\\u1CF7\\u302E-\\u302F\\uA953\\uA9C0\\uAA7B\\uAA7D\\uABEC\\u{111C0}\\u{11235}\\u{1134D}\\u{116B6}\\u{1D16D}-\\u{1D172}\\u09BE\\u09D7\\u0B3E\\u0B57\\u0BBE\\u0BD7\\u0CC2\\u0CD5-\\u0CD6\\u0D3E\\u0D57\\u0DCF\\u0DDF\\u302E-\\u302F\\u{1133E}\\u{11357}\\u{114B0}\\u{114BD}\\u{115AF}\\u{1D165}\\u{1D16E}-\\u{1D172}]";
var Nd = "[\\u{1D7CE}-\\u{1D7FF}\\uFF10-\\uFF19]";
var Pc = "\\u2040";
var Other_ID_Start = "[\\u1885-\\u1886\\u2118\\u212E\\u309B-\\u309C]";
var Other_ID_Continue = "[\\u00B7\\u0387\\u1369-\\u1371\\u19DA]";
var id_start = group(Lu, Ll, Lt, Lm, Lo, Nl, the_underscore, Other_ID_Start);
var id_continue = group(id_start, Mn, Mc, Nd, Pc, Other_ID_Continue);
var isidentifier_regex; // Fall back if we don't support unicode

if (RegExp().unicode === false) {
  isidentifier_regex = new RegExp('^' + id_start + '+' + id_continue + '*$', 'u');
} else {
  id_start = group(Lu, Ll, the_underscore);
  id_continue = group(id_start, '[0-9]');
  isidentifier_regex = new RegExp('^' + id_start + '+' + id_continue + '*$');
}
/**
 * test if string is an identifier
 *
 * @param {str} string
 * @returns {boolean}
 */


function isidentifier(str) {
  var normalized = str.normalize('NFKC');
  return isidentifier_regex.test(normalized);
}
/* we have to use string and ctor to be able to build patterns up. + on /.../
 * does something strange.
 * Note: we use unicode matching for names ("\w") but ascii matching for
 * number literals.
 *
 * I don't know if the comment above is still actually correct */


var Whitespace = "[ \\f\\t]*";
var Comment_ = "#[^\\r\\n]*";
var Ignore = Whitespace + any('\\\\\\r?\\n' + Whitespace) + maybe(Comment_);
var Name = "\\w+";
var Exponent = "[eE][-+]?[0-9](?:_?[0-9])*";
var Pointfloat = group('[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?', '\\.[0-9](?:_?[0-9])*') + maybe(Exponent);
var Expfloat = "[0-9](?:_?[0-9])*" + Exponent;
var Floatnumber = group(Pointfloat, Expfloat);
var Imagnumber = group("[0-9](?:_?[0-9])*[jJ]", Floatnumber + "[jJ]"); // Return the empty string, plus all of the valid string prefixes.

function _all_string_prefixes() {
  return ['', 'FR', 'RF', 'Br', 'BR', 'Fr', 'r', 'B', 'R', 'b', 'bR', 'f', 'rb', 'rB', 'F', 'Rf', 'U', 'rF', 'u', 'RB', 'br', 'fR', 'fr', 'rf', 'Rb'];
} // Note that since _all_string_prefixes includes the empty string,
//  StringPrefix can be the empty string (making it optional).


var StringPrefix = group.apply(null, _all_string_prefixes()); // these regexes differ from python because .exec doesn't do the
// same thing as .match in python. It's more like .search.
// .match matches from the start of the string.
// to get the same behaviour we can add a ^ to the start of the
// regex
// Tail end of ' string.

var Single = "^[^'\\\\]*(?:\\\\.[^'\\\\]*)*'"; // Tail end of " string.

var Double = '^[^"\\\\]*(?:\\\\.[^"\\\\]*)*"'; // Tail end of ''' string.

var Single3 = "^[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''"; // Tail end of """ string.

var Double3 = '^[^"\\\\]*(?:(?:\\\\.|"(?!""))[^"\\\\]*)*"""';
var Triple = group(StringPrefix + "'''", StringPrefix + '"""'); // Single-line ' or " string.

var String_ = group(StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'", StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*"'); // Sorting in reverse order puts the long operators before their prefixes.
// Otherwise if = came before ==, == would get recognized as two instances
// of =.

var EXACT_TOKENS_SORTED = Object.keys(Sk.token.EXACT_TOKEN_TYPES).sort();
var Special = group.apply(void 0, EXACT_TOKENS_SORTED.reverse().map(function (t) {
  return regexEscape(t);
}));
var Funny = group('\\r?\\n', Special); // these aren't actually used
// var PlainToken = group(Number_, Funny, String_, Name);
// var Token = Ignore + PlainToken;
// First (or only) line of ' or " string.

var ContStr = group(StringPrefix + "'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*" + group("'", '\\\\\\r?\\n'), StringPrefix + '"[^\\n"\\\\]*(?:\\\\.[^\\n"\\\\]*)*' + group('"', '\\\\\\r?\\n'));
var PseudoExtras = group('\\\\\\r?\\n|$', Comment_, Triple); // For a given string prefix plus quotes, endpats maps it to a regex
//  to match the remainder of that string. _prefix can be empty, for
//  a normal single or triple quoted string (with no prefix).

var endpats = {};

var prefixes = _all_string_prefixes();

var _iterator = _createForOfIteratorHelper(prefixes),
    _step;

try {
  for (_iterator.s(); !(_step = _iterator.n()).done;) {
    var _prefix = _step.value;
    endpats[_prefix + "'"] = RegExp(Single);
    endpats[_prefix + '"'] = RegExp(Double);
    endpats[_prefix + "'''"] = RegExp(Single3);
    endpats[_prefix + '"""'] = RegExp(Double3);
  } // A set of all of the single and triple quoted string prefixes,
  //  including the opening quotes.

} catch (err) {
  _iterator.e(err);
} finally {
  _iterator.f();
}

var single_quoted = [];
var triple_quoted = [];

var _iterator2 = _createForOfIteratorHelper(prefixes),
    _step2;

try {
  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
    var t = _step2.value;
    single_quoted.push(t + '"');
    single_quoted.push(t + "'");
    triple_quoted.push(t + '"""');
    triple_quoted.push(t + "'''");
  }
} catch (err) {
  _iterator2.e(err);
} finally {
  _iterator2.f();
}

var tabsize = 8;
var PseudoTokenRegex;

function _setupTokenRegexes() {
  // we make these regexes here because they can
  // be changed by the configuration.
  var LSuffix = Sk.__future__.l_suffix ? '(?:L?)' : '';
  var Hexnumber = '0[xX](?:_?[0-9a-fA-F])+' + LSuffix;
  var Binnumber = '0[bB](?:_?[01])+' + LSuffix;
  var Octnumber = '0([oO])(?:_?[0-7])+' + LSuffix;
  var SilentOctnumber = '0([oO]?)(?:_?[0-7])+' + LSuffix;
  var Decnumber = '(?:0(?:_?0)*|[1-9](?:_?[0-9])*)' + LSuffix;
  var Intnumber = group(Hexnumber, Binnumber, Sk.__future__.silent_octal_literal ? SilentOctnumber : Octnumber, Decnumber);
  var Number_ = group(Imagnumber, Floatnumber, Intnumber);
  var PseudoToken = Whitespace + group(PseudoExtras, Number_, Funny, ContStr, Name);
  PseudoTokenRegex = RegExp(PseudoToken);
}

Sk._setupTokenRegexes = _setupTokenRegexes;
Sk.exportSymbol("Sk._setupTokenRegexes", Sk._setupTokenRegexes);
/**
 * internal tokenize function
 *
 * @param {function(): string} readline
 * @param {string} encoding
 * @param {function(TokenInfo): void} yield_
 */

function _tokenize(readline, encoding, yield_, filename) {
  var lnum = 0,
      parenlev = 0,
      continued = 0,
      numchars = '0123456789',
      contstr = '',
      needcont = 0,
      contline = null,
      indents = [0],
      spos = [0, 0],
      epos = [0, 0],
      capos = null,
      endprog = undefined,
      strstart = undefined,
      end = undefined,
      pseudomatch = undefined;

  if (encoding !== undefined) {
    if (encoding == "utf-8-sig") {
      // BOM will already have been stripped.
      encoding = "utf-8";
    }

    yield_(new TokenInfo(tokens.T_ENCODING, encoding, [0, 0], [0, 0], ''));
  }

  var last_line = '';
  var line = '';

  while (true) {
    // loop over lines in stream
    try {
      // We capture the value of the line variable here because
      // readline uses the empty string '' to signal end of input,
      // hence `line` itself will always be overwritten at the end
      // of this loop.
      last_line = line;
      line = readline();
    } catch (Exception) {
      line = '';
    } // lets pretend this doesn't exist for now.
    // if encoding is not None:
    //     line = line.decode(encoding)


    lnum += 1;
    var pos = 0;
    var max = line.length;

    if (contstr) {
      // continued string
      if (!line) {
        //throw new TokenError("EOF in multi-line string", strstart);
        throw new TokenError("EOF in multi-line string", filename, spos[0], [spos, epos]);
      }

      endprog.lastIndex = 0;
      var endmatch = endprog.exec(line);

      if (endmatch) {
        pos = end = endmatch[0].length;
        yield_(new TokenInfo(tokens.T_STRING, contstr + line.substring(0, end), strstart, [lnum, end], contline + line));
        contstr = '';
        needcont = 0;
        contline = null;
      } else if (needcont && line.substring(line.length - 2) !== "\\\n" && line.substring(line.length - 3) !== "\\\r\n") {
        yield_(new TokenInfo(tokens.T_ERRORTOKEN, contstr + line, strstart, [lnum, line.length], contline));
        contstr = '';
        contline = null;
        continue;
      } else {
        contstr = contstr + line;
        contline = contline + line;
        continue;
      }
    } else if (parenlev == 0 && !continued) {
      // new statement
      if (!line) {
        break;
      }

      var column = 0;

      while (pos < max) {
        // measure leading whitespace
        if (line[pos] == ' ') {
          column += 1;
        } else if (line[pos] == '\t') {
          column = Math.floor(column / tabsize + 1) * tabsize;
        } else if (line[pos] == '\f') {
          column = 0;
        } else {
          break;
        }

        ;
        pos += 1;
      }

      if (pos == max) {
        break;
      }

      if (contains('#\r\n', line[pos])) {
        // skip comments or blank lines
        if (line[pos] == '#') {
          var comment_token = rstrip(line.substring(pos), '\r\n');
          yield_(new TokenInfo(tokens.T_COMMENT, comment_token, [lnum, pos], [lnum, pos + comment_token.length], line));
          pos += comment_token.length;
        }

        yield_(new TokenInfo(tokens.T_NL, line.substring(pos), [lnum, pos], [lnum, line.length], line));
        continue;
      }

      if (column > indents[indents.length - 1]) {
        // count indents or dedents
        indents.push(column);
        yield_(new TokenInfo(tokens.T_INDENT, line.substring(pos), [lnum, 0], [lnum, pos], line));
      }

      while (column < indents[indents.length - 1]) {
        if (!contains(indents, column)) {
          throw new IndentationError("unindent does not match any outer indentation level", filename, spos[0], [spos, epos]); //["<tokenize>", lnum, pos, line]);
        }

        indents = indents.slice(0, -1);
        yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, pos], [lnum, pos], line));
      }
    } else {
      // continued statement
      if (!line) {
        //throw new TokenError("EOF in multi-line statement", [lnum, 0]);
        throw new TokenError("EOF in multi-line statement", filename, spos[0], [spos, epos]);
      }

      continued = 0;
    }

    while (pos < max) {
      //console.log("pos:"+pos+":"+max);
      // js regexes don't return any info about matches, other than the
      // content. we'd like to put a \w+ before pseudomatch, but then we
      // can't get any data
      capos = line.charAt(pos);

      while (capos === ' ' || capos === '\f' || capos === '\t') {
        pos += 1;
        capos = line.charAt(pos);
      }

      pseudomatch = PseudoTokenRegex.exec(line.substring(pos));

      if (pseudomatch) {
        // scan for tokens
        var start = pos;
        var end = start + pseudomatch[1].length;
        spos = [lnum, start];
        epos = [lnum, end];
        var pos = end;

        if (start == end) {
          continue;
        }

        var token = line.substring(start, end);
        var initial = line[start]; //console.log("token:",token, "initial:",initial, start, end);

        if (contains(numchars, initial) || // ordinary number
        initial == '.' && token != '.' && token != '...') {
          yield_(new TokenInfo(tokens.T_NUMBER, token, spos, epos, line));
        } else if (contains('\r\n', initial)) {
          if (parenlev > 0) {
            yield_(new TokenInfo(tokens.T_NL, token, spos, epos, line));
          } else {
            yield_(new TokenInfo(tokens.T_NEWLINE, token, spos, epos, line));
          }
        } else if (initial == '#') {
          //assert not token.endswith("\n")
          yield_(new TokenInfo(tokens.T_COMMENT, token, spos, epos, line));
        } else if (contains(triple_quoted, token)) {
          endprog = endpats[token];
          endmatch = endprog.exec(line.substring(pos));

          if (endmatch) {
            // all on one line
            pos = endmatch[0].length + pos;
            token = line.substring(start, pos);
            yield_(new TokenInfo(tokens.T_STRING, token, spos, [lnum, pos], line));
          } else {
            strstart = [lnum, start]; // multiple lines

            contstr = line.substring(start);
            contline = line;
            break;
          } // Check up to the first 3 chars of the token to see if
          //  they're in the single_quoted set. If so, they start
          //  a string.
          // We're using the first 3, because we're looking for
          //  "rb'" (for example) at the start of the token. If
          //  we switch to longer prefixes, this needs to be
          //  adjusted.
          // Note that initial == token[:1].
          // Also note that single quote checking must come after
          //  triple quote checking (above).

        } else if (contains(single_quoted, initial) || contains(single_quoted, token.substring(0, 2)) || contains(single_quoted, token.substring(0, 3))) {
          if (token[token.length - 1] == '\n') {
            // continued string
            strstart = [lnum, start]; // Again, using the first 3 chars of the
            //  token. This is looking for the matching end
            //  regex for the correct type of quote
            //  character. So it's really looking for
            //  endpats["'"] or endpats['"'], by trying to
            //  skip string prefix characters, if any.

            endprog = endpats[initial] || endpats[token[1]] || endpats[token[2]];
            contstr = line.substring(start);
            needcont = 1;
            contline = line;
            break;
          } else {
            // ordinary string
            yield_(new TokenInfo(tokens.T_STRING, token, spos, epos, line));
          }
        } else if (isidentifier(initial)) {
          // ordinary name
          yield_(new TokenInfo(tokens.T_NAME, token, spos, epos, line));
        } else if (initial == '\\') {
          // continued stmt
          continued = 1;
        } else {
          if (contains('([{', initial)) {
            parenlev += 1;
          } else if (contains(')]}', initial)) {
            parenlev -= 1;
          }

          yield_(new TokenInfo(tokens.T_OP, token, spos, epos, line));
        }
      } else {
        yield_(new TokenInfo(tokens.T_ERRORTOKEN, line[pos], [lnum, pos], [lnum, pos + 1], line));
        pos += 1;
      }
    }
  } // Add an implicit NEWLINE if the input doesn't end in one


  if (last_line && !contains('\r\n', last_line[last_line.length - 1])) {
    yield_(new TokenInfo(tokens.T_NEWLINE, '', [lnum - 1, last_line.length], [lnum - 1, last_line.length + 1], ''));
  }

  for (var i in indents.slice(1)) {
    // pop remaining indent levels
    yield_(new TokenInfo(tokens.T_DEDENT, '', [lnum, 0], [lnum, 0], ''));
  }

  yield_(new TokenInfo(tokens.T_ENDMARKER, '', [lnum, 0], [lnum, 0], ''));
}

Sk._tokenize = _tokenize;
Sk.exportSymbol("Sk._tokenize", Sk._tokenize); // low level parser to a concrete syntax tree, derived from cpython's lib2to3

/**
 *
 * @constructor
 * @param {Object} grammar
 *
 * p = new Parser(grammar);
 * p.setup([start]);
 * foreach input token:
 *     if p.addtoken(...):
 *         break
 * root = p.rootnode
 *
 * can throw SyntaxError
 */

function Parser(filename, grammar) {
  this.filename = filename;
  this.grammar = grammar;
  this.comments = {};
  this.p_flags = 0;
  return this;
} // all possible parser flags


Parser.FUTURE_PRINT_FUNCTION = "print_function";
Parser.FUTURE_UNICODE_LITERALS = "unicode_literals";
Parser.FUTURE_DIVISION = "division";
Parser.FUTURE_ABSOLUTE_IMPORT = "absolute_import";
Parser.FUTURE_WITH_STATEMENT = "with_statement";
Parser.FUTURE_NESTED_SCOPES = "nested_scopes";
Parser.FUTURE_GENERATORS = "generators";
Parser.CO_FUTURE_PRINT_FUNCTION = 0x10000;
Parser.CO_FUTURE_UNICODE_LITERALS = 0x20000;
Parser.CO_FUTURE_DIVISON = 0x2000;
Parser.CO_FUTURE_ABSOLUTE_IMPORT = 0x4000;
Parser.CO_FUTURE_WITH_STATEMENT = 0x8000;

Parser.prototype.setup = function (start) {
  var stackentry;
  var newnode;
  start = start || this.grammar.start; //print("START:"+start);

  newnode = {
    type: start,
    value: null,
    context: null,
    children: []
  };
  stackentry = {
    dfa: this.grammar.dfas[start],
    state: 0,
    node: newnode
  };
  this.stack = [stackentry];
  this.used_names = {};

  Sk._setupTokenRegexes();
};

function findInDfa(a, obj) {
  var i = a.length;

  while (i--) {
    if (a[i][0] === obj[0] && a[i][1] === obj[1]) {
      return true;
    }
  }

  return false;
} // Add a comment


Parser.prototype.addcomment = function (value, start, end, line) {
  if (start[1] != line.search(/\S/)) start[1] = line.search(/\S/);
  this.comments[start] = value;
}; // Add a token; return true if we're done


Parser.prototype.addtoken = function (type, value, context) {
  var errline;
  var itsfirst;
  var itsdfa;
  var state;
  var v;
  var t;
  var newstate;
  var i;
  var a;
  var arcs;
  var first;
  var states;
  var tp;
  var ilabel = this.classify(type, value, context); //print("ilabel:"+ilabel);

  OUTERWHILE: while (true) {
    tp = this.stack[this.stack.length - 1];
    states = tp.dfa[0];
    first = tp.dfa[1];
    arcs = states[tp.state]; // look for a state with this label

    for (a = 0; a < arcs.length; ++a) {
      i = arcs[a][0];
      newstate = arcs[a][1];
      t = this.grammar.labels[i][0];
      v = this.grammar.labels[i][1];

      if (ilabel === i) {
        // look it up in the list of labels
        Sk.asserts.assert(t < 256); // shift a token; we're done with it

        this.shift(type, value, newstate, context); // pop while we are in an accept-only state

        state = newstate; //print("before:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));

        /* jshint ignore:start */

        while (states[state].length === 1 && states[state][0][0] === 0 && states[state][0][1] === state) {
          // states[state] == [(0, state)])
          this.pop(); //print("in after pop:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));

          if (this.stack.length === 0) {
            // done!
            return true;
          }

          tp = this.stack[this.stack.length - 1];
          state = tp.state;
          states = tp.dfa[0];
          first = tp.dfa[1]; //print(JSON.stringify(states), JSON.stringify(first));
          //print("bottom:"+JSON.stringify(states[state]) + ":state:"+state+":"+JSON.stringify(states[state]));
        }
        /* jshint ignore:end */
        // done with this token
        //print("DONE, return false");


        return false;
      } else if (t >= 256) {
        itsdfa = this.grammar.dfas[t];
        itsfirst = itsdfa[1];

        if (itsfirst.hasOwnProperty(ilabel)) {
          // push a symbol
          this.push(t, this.grammar.dfas[t], newstate, context);
          continue OUTERWHILE;
        }
      }
    } //print("findInDfa: " + JSON.stringify(arcs)+" vs. " + tp.state);


    if (findInDfa(arcs, [0, tp.state])) {
      // an accepting state, pop it and try something else
      //print("WAA");
      this.pop();

      if (this.stack.length === 0) {
        throw new Sk.builtin.SyntaxError("too much input", this.filename);
      }
    } else {
      // no transition
      errline = context[0][0];
      throw new Sk.builtin.SyntaxError("bad input", this.filename, errline, context);
    }
  }
}; // turn a token into a label


Parser.prototype.classify = function (type, value, context) {
  var ilabel;

  if (type === Sk.token.tokens.T_NAME) {
    this.used_names[value] = true;
    ilabel = this.grammar.keywords.hasOwnProperty(value) && this.grammar.keywords[value];
    /* Check for handling print as an builtin function */

    if (value === "print" && (this.p_flags & Parser.CO_FUTURE_PRINT_FUNCTION || Sk.__future__.print_function === true)) {
      ilabel = false; // ilabel determines if the value is a keyword
    }

    if (ilabel) {
      //print("is keyword");
      return ilabel;
    }
  }

  ilabel = this.grammar.tokens.hasOwnProperty(type) && this.grammar.tokens[type];

  if (!ilabel) {
    // throw new Sk.builtin.SyntaxError("bad token", type, value, context);
    // Questionable modification to put line number in position 2
    // like everywhere else and filename in position 1.
    var descr = "#" + type;

    for (var i in Sk.token.tokens) {
      if (Sk.token.tokens[i] == type) {
        descr = i;
        break;
      }
    }

    throw new Sk.builtin.SyntaxError("bad token " + descr, this.filename, context[0][0], context);
  }

  return ilabel;
}; // shift a token


Parser.prototype.shift = function (type, value, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var state = this.stack[this.stack.length - 1].state;
  var node = this.stack[this.stack.length - 1].node; //print("context", context);

  var newnode = {
    type: type,
    value: value,
    lineno: context[0][0],
    col_offset: context[0][1],
    end_lineno: context[1][0],
    end_col_offset: context[1][1],
    children: null
  };

  if (newnode) {
    node.children.push(newnode);
  }

  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
}; // push a nonterminal


Parser.prototype.push = function (type, newdfa, newstate, context) {
  var dfa = this.stack[this.stack.length - 1].dfa;
  var node = this.stack[this.stack.length - 1].node;
  var newnode = {
    type: type,
    value: null,
    lineno: context[0][0],
    col_offset: context[0][1],
    end_lineno: context[1][0],
    end_col_offset: context[1][1],
    children: []
  };
  this.stack[this.stack.length - 1] = {
    dfa: dfa,
    state: newstate,
    node: node
  };
  this.stack.push({
    dfa: newdfa,
    state: 0,
    node: newnode
  });
}; //var ac = 0;
//var bc = 0;
// pop a nonterminal


Parser.prototype.pop = function () {
  var node;
  var pop = this.stack.pop();
  var newnode = pop.node; //print("POP");

  if (newnode) {
    //print("A", ac++, newnode.type);
    //print("stacklen:"+this.stack.length);
    if (this.stack.length !== 0) {
      //print("B", bc++);
      node = this.stack[this.stack.length - 1].node;
      node.children.push(newnode);
    } else {
      //print("C");
      this.rootnode = newnode;
      this.rootnode.used_names = this.used_names;
    }
  }
};
/**
 * parser for interactive input. returns a function that should be called with
 * lines of input as they are entered. the function will return false
 * until the input is complete, when it will return the rootnode of the parse.
 *
 * @param {string} filename
 * @param {string=} style root of parse tree (optional)
 */


function makeParser(filename, style) {
  if (style === undefined) {
    style = "file_input";
  }

  var p = new Parser(filename, Sk.ParseTables); // for closure's benefit

  if (style === "file_input") {
    p.setup(Sk.ParseTables.sym.file_input);
  } else {
    Sk.asserts.fail("todo;");
  }

  return p;
}

Sk.parse = function parse(filename, input) {
  var T_COMMENT = Sk.token.tokens.T_COMMENT;
  var T_NL = Sk.token.tokens.T_NL;
  var T_OP = Sk.token.tokens.T_OP;
  var T_ENDMARKER = Sk.token.tokens.T_ENDMARKER;
  var T_ENCODING = Sk.token.tokens.T_ENCODING;
  var endmarker_seen = false;
  var parser = makeParser(filename);
  /**
   * takes a string splits it on '\n' and returns a function that returns
   * @param {Array<string>} input
   * @returns {function(): string}
   */

  function readline(input) {
    var lines = input.split("\n").reverse(); //.map(function (l) { return l + "\n"; });

    return function () {
      if (lines.length === 0) {
        throw new Sk.builtin.Exception("EOF");
      }

      return lines.pop() + "\n";
    };
  }

  Sk._tokenize(readline(input), "utf-8", function (tokenInfo) {
    var s_lineno = tokenInfo.start[0];
    var s_column = tokenInfo.start[1];
    var type = null;
    var prefix, lineno, column;
    /* I don't know
     if (s_lineno !== lineno && s_column !== column)
     {
     // todo; update prefix and line/col
     }
     */

    if (tokenInfo.type === T_COMMENT || tokenInfo.type === T_NL || tokenInfo.type === T_ENCODING) {
      prefix += tokenInfo.value;
      lineno = tokenInfo.end[0];
      column = tokenInfo.end[1];

      if (tokenInfo.string[tokenInfo.string.length - 1] === "\n") {
        lineno += 1;
        column = 0;
      }

      if (tokenInfo.type === T_COMMENT) {
        parser.addcomment(tokenInfo.string, tokenInfo.start, tokenInfo.end, tokenInfo.line);
      }
    } else {
      if (tokenInfo.type === T_OP) {
        type = Sk.OpMap[tokenInfo.string];
      }

      parser.addtoken(type || tokenInfo.type, tokenInfo.string, [tokenInfo.start, tokenInfo.end, tokenInfo.line]);

      if (tokenInfo.type === T_ENDMARKER) {
        endmarker_seen = true;
      }
    }
  }, filename);

  if (!endmarker_seen) {
    throw new Sk.builtin.SyntaxError("incomplete input", this.filename);
  }
  /**
   * Small adjustments here in order to return th flags and the cst
   */


  var result = {
    "cst": parser.rootnode,
    "flags": parser.p_flags,
    "comments": parser.comments
  };
  return result;
};

Sk.parseTreeDump = function parseTreeDump(n, indent) {
  //return JSON.stringify(n, null, 2);
  var i;
  var ret;
  indent = indent || "";
  ret = "";
  ret += indent;

  if (n.type >= 256) {
    // non-term
    ret += Sk.ParseTables.number2symbol[n.type] + "\n";

    for (i = 0; i < n.children.length; ++i) {
      ret += Sk.parseTreeDump(n.children[i], indent + "  ");
    }
  } else {
    ret += Sk.token.tok_name[n.type] + ": " + new Sk.builtin.str(n.value)["$r"]().v + "\n";
  }

  return ret;
};

Sk.exportSymbol("Sk.Parser", Parser);
Sk.exportSymbol("Sk.parse", Sk.parse);
Sk.exportSymbol("Sk.parseTreeDump", Sk.parseTreeDump); //
// This is pretty much a straight port of ast.c from CPython 3.7.3
// (with a few leftovers from 2.6.5).
//
// The previous version was easier to work with and more JS-ish, but having a
// somewhat different ast structure than cpython makes testing more difficult.
//
// This way, we can use a dump from the ast module on any arbitrary python
// code and know that we're the same up to ast level, at least.
//

var SYM = Sk.ParseTables.sym;
var TOK = Sk.token.tokens;
var COMP_GENEXP = 0;
var COMP_LISTCOMP = 1;
var COMP_SETCOMP = 2;
var NULL = null;
var _slice_kind = {
  Slice_kind: 1,
  ExtSlice_kind: 2,
  Index_kind: 3
};
var _expr_kind = {
  BoolOp_kind: 1,
  NamedExpr_kind: 2,
  BinOp_kind: 3,
  UnaryOp_kind: 4,
  Lambda_kind: 5,
  IfExp_kind: 6,
  Dict_kind: 7,
  Set_kind: 8,
  ListComp_kind: 9,
  SetComp_kind: 10,
  DictComp_kind: 11,
  GeneratorExp_kind: 12,
  Await_kind: 13,
  Yield_kind: 14,
  YieldFrom_kind: 15,
  Compare_kind: 16,
  Call_kind: 17,
  FormattedValue_kind: 18,
  JoinedStr_kind: 19,
  Constant_kind: 20,
  Attribute_kind: 21,
  Subscript_kind: 22,
  Starred_kind: 23,
  Name_kind: 24,
  List_kind: 25,
  Tuple_kind: 26
};
/** @constructor */

function Compiling(encoding, filename, c_flags) {
  this.c_encoding = encoding;
  this.c_filename = filename;
  this.c_flags = c_flags || 0;
}
/**
 * @return {number}
 */


function NCH(n) {
  Sk.asserts.assert(n !== undefined, "node must be defined");

  if (n.children === null) {
    return 0;
  }

  return n.children.length;
}

function CHILD(n, i) {
  Sk.asserts.assert(n !== undefined, "node must be defined");
  Sk.asserts.assert(i !== undefined, "index of child must be specified");
  return n.children[i];
}

function REQ(n, type) {
  Sk.asserts.assert(n.type === type, "node wasn't expected type");
}

function TYPE(n) {
  return n.type;
}

function LINENO(n) {
  return n.lineno;
}

function STR(ch) {
  return ch.value;
}

function ast_error(c, n, msg) {
  throw new Sk.builtin.SyntaxError(msg, c.c_filename, n.lineno);
}

function strobj(s) {
  Sk.asserts.assert(typeof s === "string", "expecting string, got " + _typeof(s));
  return new Sk.builtin.str(s);
}
/** @return {number} */


function numStmts(n) {
  var ch;
  var i;
  var cnt;

  switch (n.type) {
    case SYM.single_input:
      if (CHILD(n, 0).type === TOK.T_NEWLINE) {
        return 0;
      } else {
        return numStmts(CHILD(n, 0));
      }

    case SYM.file_input:
      cnt = 0;

      for (i = 0; i < NCH(n); ++i) {
        ch = CHILD(n, i);

        if (ch.type === SYM.stmt) {
          cnt += numStmts(ch);
        }
      }

      return cnt;

    case SYM.stmt:
      return numStmts(CHILD(n, 0));

    case SYM.compound_stmt:
      return 1;

    case SYM.simple_stmt:
      return Math.floor(NCH(n) / 2);
    // div 2 is to remove count of ;s

    case SYM.suite:
      if (NCH(n) === 1) {
        return numStmts(CHILD(n, 0));
      } else {
        cnt = 0;

        for (i = 2; i < NCH(n) - 1; ++i) {
          cnt += numStmts(CHILD(n, i));
        }

        return cnt;
      }

      break;

    default:
      Sk.asserts.fail("Non-statement found");
  }

  return 0;
}

function forbiddenCheck(c, n, x, lineno) {
  if (x instanceof Sk.builtin.str) {
    x = x.v;
  }

  if (x === "None") {
    throw new Sk.builtin.SyntaxError("assignment to None", c.c_filename, lineno);
  }

  if (x === "True" || x === "False") {
    throw new Sk.builtin.SyntaxError("assignment to True or False is forbidden", c.c_filename, lineno);
  }
}
/**
 * Set the context ctx for e, recursively traversing e.
 *
 * Only sets context for expr kinds that can appear in assignment context as
 * per the asdl file.
 */


function setContext(c, e, ctx, n) {
  var i;
  var exprName;
  var s;
  Sk.asserts.assert(ctx !== Sk.astnodes.AugStore && ctx !== Sk.astnodes.AugLoad, "context not AugStore or AugLoad");
  s = null;
  exprName = null;

  switch (e.constructor) {
    case Sk.astnodes.Attribute:
    case Sk.astnodes.Name:
      if (ctx === Sk.astnodes.Store) {
        forbiddenCheck(c, n, e.attr, n.lineno);
      }

      e.ctx = ctx;
      break;

    case Sk.astnodes.Subscript:
      e.ctx = ctx;
      break;

    case Sk.astnodes.List:
      e.ctx = ctx;
      s = e.elts;
      break;

    case Sk.astnodes.Tuple:
      if (e.elts.length === 0) {
        throw new Sk.builtin.SyntaxError("can't assign to ()", c.c_filename, n.lineno);
      }

      e.ctx = ctx;
      s = e.elts;
      break;

    case Sk.astnodes.Lambda:
      exprName = "lambda";
      break;

    case Sk.astnodes.Call:
      exprName = "function call";
      break;

    case Sk.astnodes.BoolOp:
    case Sk.astnodes.BinOp:
    case Sk.astnodes.UnaryOp:
      exprName = "operator";
      break;

    case Sk.astnodes.GeneratorExp:
      exprName = "generator expression";
      break;

    case Sk.astnodes.Yield:
      exprName = "yield expression";
      break;

    case Sk.astnodes.ListComp:
      exprName = "list comprehension";
      break;

    case Sk.astnodes.SetComp:
      exprName = "set comprehension";
      break;

    case Sk.astnodes.DictComp:
      exprName = "dict comprehension";
      break;

    case Sk.astnodes.Dict:
    case Sk.astnodes.Set:
    case Sk.astnodes.Num:
    case Sk.astnodes.Str:
      exprName = "literal";
      break;

    case Sk.astnodes.NameConstant:
      exprName = "True, False or None";
      break;

    case Sk.astnodes.Compare:
      exprName = "comparison";
      break;

    case Sk.astnodes.Repr:
      exprName = "repr";
      break;

    case Sk.astnodes.IfExp:
      exprName = "conditional expression";
      break;

    default:
      Sk.asserts.fail("unhandled expression in assignment");
  }

  if (exprName) {
    throw new Sk.builtin.SyntaxError("can't " + (ctx === Sk.astnodes.Store ? "assign to" : "delete") + " " + exprName, c.c_filename, n.lineno);
  }

  if (s) {
    for (i = 0; i < s.length; ++i) {
      setContext(c, s[i], ctx, n);
    }
  }
}

var operatorMap = {};

(function () {
  operatorMap[TOK.T_VBAR] = Sk.astnodes.BitOr;
  operatorMap[TOK.T_CIRCUMFLEX] = Sk.astnodes.BitXor;
  operatorMap[TOK.T_AMPER] = Sk.astnodes.BitAnd;
  operatorMap[TOK.T_LEFTSHIFT] = Sk.astnodes.LShift;
  operatorMap[TOK.T_RIGHTSHIFT] = Sk.astnodes.RShift;
  operatorMap[TOK.T_PLUS] = Sk.astnodes.Add;
  operatorMap[TOK.T_MINUS] = Sk.astnodes.Sub;
  operatorMap[TOK.T_STAR] = Sk.astnodes.Mult;
  operatorMap[TOK.T_SLASH] = Sk.astnodes.Div;
  operatorMap[TOK.T_DOUBLESLASH] = Sk.astnodes.FloorDiv;
  operatorMap[TOK.T_PERCENT] = Sk.astnodes.Mod;
})();

Sk.setupOperators = function (py3) {
  if (py3) {
    operatorMap[TOK.T_AT] = Sk.astnodes.MatMult;
  } else {
    if (operatorMap[TOK.T_AT]) {
      delete operatorMap[TOK.T_AT];
    }
  }
};

Sk.exportSymbol("Sk.setupOperators", Sk.setupOperators);

function getOperator(n) {
  if (operatorMap[n.type] === undefined) {
    throw new Sk.builtin.SyntaxError("invalid syntax", n.type, n.lineno);
  }

  return operatorMap[n.type];
}

function new_identifier(n, c) {
  if (n.value) {
    return Sk.builtin.str(n.value);
  }

  return Sk.builtin.str(n);
}

function astForCompOp(c, n) {
  /* comp_op: '<'|'>'|'=='|'>='|'<='|'!='|'in'|'not' 'in'|'is'
   |'is' 'not'
   */
  REQ(n, SYM.comp_op);

  if (NCH(n) === 1) {
    n = CHILD(n, 0);

    switch (n.type) {
      case TOK.T_LESS:
        return Sk.astnodes.Lt;

      case TOK.T_GREATER:
        return Sk.astnodes.Gt;

      case TOK.T_EQEQUAL:
        return Sk.astnodes.Eq;

      case TOK.T_LESSEQUAL:
        return Sk.astnodes.LtE;

      case TOK.T_GREATEREQUAL:
        return Sk.astnodes.GtE;

      case TOK.T_NOTEQUAL:
        return Sk.astnodes.NotEq;

      case TOK.T_NAME:
        if (n.value === "in") {
          return Sk.astnodes.In;
        }

        if (n.value === "is") {
          return Sk.astnodes.Is;
        }

    }
  } else if (NCH(n) === 2) {
    if (CHILD(n, 0).type === TOK.T_NAME) {
      if (CHILD(n, 1).value === "in") {
        return Sk.astnodes.NotIn;
      }

      if (CHILD(n, 0).value === "is") {
        return Sk.astnodes.IsNot;
      }
    }
  }

  Sk.asserts.fail("invalid comp_op");
}

function copy_location(e, n) {
  if (e) {
    e.lineno = LINENO(n);
    e.col_offset = n.col_offset;
    e.end_lineno = n.end_lineno;
    e.end_col_offset = n.end_col_offset;
  }

  return e;
}

function seq_for_testlist(c, n) {
  /* testlist: test (',' test)* [',']
     testlist_star_expr: test|star_expr (',' test|star_expr)* [',']
  */
  var i;
  var seq = [];
  Sk.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_star_expr || n.type === SYM.listmaker || n.type === SYM.testlist_comp || n.type === SYM.testlist_safe || n.type === SYM.testlist1, "node type must be listlike");

  for (i = 0; i < NCH(n); i += 2) {
    Sk.asserts.assert(CHILD(n, i).type === SYM.test || CHILD(n, i).type === SYM.old_test || CHILD(n, i).type === SYM.star_expr);
    seq[i / 2] = ast_for_expr(c, CHILD(n, i));
  }

  return seq;
}

function astForSuite(c, n) {
  /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */
  var j;
  var num;
  var i;
  var end;
  var ch;
  var pos;
  var seq;
  REQ(n, SYM.suite);
  seq = [];
  pos = 0;

  if (CHILD(n, 0).type === SYM.simple_stmt) {
    n = CHILD(n, 0);
    /* simple_stmt always ends with an NEWLINE and may have a trailing
     * SEMI. */

    end = NCH(n) - 1;

    if (CHILD(n, end - 1).type === TOK.T_SEMI) {
      end -= 1;
    }

    for (i = 0; i < end; i += 2) // by 2 to skip ;
    {
      seq[pos++] = astForStmt(c, CHILD(n, i));
    }
  } else {
    for (i = 2; i < NCH(n) - 1; ++i) {
      ch = CHILD(n, i);
      REQ(ch, SYM.stmt);
      num = numStmts(ch);

      if (num === 1) {
        // small_stmt or compound_stmt w/ only 1 child
        seq[pos++] = astForStmt(c, ch);
      } else {
        ch = CHILD(ch, 0);
        REQ(ch, SYM.simple_stmt);

        for (j = 0; j < NCH(ch); j += 2) {
          if (NCH(CHILD(ch, j)) === 0) {
            Sk.asserts.assert(j + 1 === NCH(ch));
            break;
          }

          seq[pos++] = astForStmt(c, CHILD(ch, j));
        }
      }
    }
  }

  Sk.asserts.assert(pos === numStmts(n));
  return seq;
}

function astForExceptClause(c, exc, body) {
  /* except_clause: 'except' [test [(',' | 'as') test]] */
  var e;
  REQ(exc, SYM.except_clause);
  REQ(body, SYM.suite);

  if (NCH(exc) === 1) {
    return new Sk.astnodes.ExceptHandler(null, null, astForSuite(c, body), exc.lineno, exc.col_offset, exc.end_lineno, exc.end_col_offset);
  } else if (NCH(exc) === 2) {
    return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), null, astForSuite(c, body), exc.lineno, exc.col_offset, exc.end_lineno, exc.end_col_offset);
  } else if (NCH(exc) === 4) {
    if (Sk.__future__.python3 && CHILD(exc, 2).value == ",") {
      ast_error(c, exc, "Old-style 'except' clauses are not supported in Python 3");
    }

    var expression = ast_for_expr(c, CHILD(exc, 1));
    e = ast_for_expr(c, CHILD(exc, 3));
    setContext(c, e, Sk.astnodes.Store, CHILD(exc, 3));
    return new Sk.astnodes.ExceptHandler(ast_for_expr(c, CHILD(exc, 1)), e, astForSuite(c, body), exc.lineno, exc.col_offset, exc.end_lineno, exc.end_col_offset);
  }

  Sk.asserts.fail("wrong number of children for except clause");
}

function astForTryStmt(c, n) {
  var exceptSt;
  var i;
  var handlers = [];
  var nc = NCH(n);
  var nexcept = (nc - 3) / 3;
  var body,
      orelse = [],
      finally_ = null;
  REQ(n, SYM.try_stmt);
  body = astForSuite(c, CHILD(n, 2));

  if (CHILD(n, nc - 3).type === TOK.T_NAME) {
    if (CHILD(n, nc - 3).value === "finally") {
      if (nc >= 9 && CHILD(n, nc - 6).type === TOK.T_NAME) {
        /* we can assume it's an "else",
         because nc >= 9 for try-else-finally and
         it would otherwise have a type of except_clause */
        orelse = astForSuite(c, CHILD(n, nc - 4));
        nexcept--;
      }

      finally_ = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    } else {
      /* we can assume it's an "else",
       otherwise it would have a type of except_clause */
      orelse = astForSuite(c, CHILD(n, nc - 1));
      nexcept--;
    }
  } else if (CHILD(n, nc - 3).type !== SYM.except_clause) {
    throw new Sk.builtin.SyntaxError("malformed 'try' statement", c.c_filename, n.lineno);
  }

  if (nexcept > 0) {
    /* process except statements to create a try ... except */
    for (i = 0; i < nexcept; i++) {
      handlers[i] = astForExceptClause(c, CHILD(n, 3 + i * 3), CHILD(n, 5 + i * 3));
    }
  }

  Sk.asserts.assert(!!finally_ || handlers.length != 0);
  return new Sk.astnodes.Try(body, handlers, orelse, finally_, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForDottedName(c, n) {
  var i;
  var e;
  var id;
  var col_offset;
  var lineno;
  REQ(n, SYM.dotted_name);
  lineno = n.lineno;
  col_offset = n.col_offset;
  id = strobj(CHILD(n, 0).value);
  e = new Sk.astnodes.Name(id, Sk.astnodes.Load, lineno, col_offset, n.end_lineno, n.end_col_offset);

  for (i = 2; i < NCH(n); i += 2) {
    id = strobj(CHILD(n, i).value);
    e = new Sk.astnodes.Attribute(e, id, Sk.astnodes.Load, lineno, col_offset, n.end_lineno, n.end_col_offset);
  }

  return e;
}

function astForDecorator(c, n) {
  /* decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE */
  var nameExpr;
  REQ(n, SYM.decorator);
  REQ(CHILD(n, 0), TOK.T_AT);
  REQ(CHILD(n, NCH(n) - 1), TOK.T_NEWLINE);
  nameExpr = astForDottedName(c, CHILD(n, 1));

  if (NCH(n) === 3) // no args
    {
      return nameExpr;
    } else if (NCH(n) === 5) // call with no args
    {
      return new Sk.astnodes.Call(nameExpr, [], [], null, null, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
    } else {
    return ast_for_call(c, CHILD(n, 3), nameExpr);
  }
}

function astForDecorators(c, n) {
  var i;
  var decoratorSeq;
  REQ(n, SYM.decorators);
  decoratorSeq = [];

  for (i = 0; i < NCH(n); ++i) {
    decoratorSeq[i] = astForDecorator(c, CHILD(n, i));
  }

  return decoratorSeq;
}

function ast_for_decorated(c, n) {
  /* decorated: decorators (classdef | funcdef | async_funcdef) */
  var thing = null;
  var decorator_seq = null;
  REQ(n, SYM.decorated);
  decorator_seq = astForDecorators(c, CHILD(n, 0));
  Sk.asserts.assert(TYPE(CHILD(n, 1)) == SYM.funcdef || TYPE(CHILD(n, 1)) == SYM.async_funcdef || TYPE(CHILD(n, 1)) == SYM.classdef);

  if (TYPE(CHILD(n, 1)) == SYM.funcdef) {
    thing = ast_for_funcdef(c, CHILD(n, 1), decorator_seq);
  } else if (TYPE(CHILD(n, 1)) == SYM.classdef) {
    thing = astForClassdef(c, CHILD(n, 1), decorator_seq);
  } else if (TYPE(CHILD(n, 1)) == SYM.async_funcdef) {
    thing = ast_for_async_funcdef(c, CHILD(n, 1), decorator_seq);
  }
  /* we count the decorators in when talking about the class' or
      * function's line number */


  if (thing) {
    thing.lineno = LINENO(n);
    thing.col_offset = n.col_offset;
  }

  return thing;
}
/* with_item: test ['as' expr] */


function ast_for_with_item(c, n) {
  var context_expr, optional_vars;
  REQ(n, SYM.with_item);
  context_expr = ast_for_expr(c, CHILD(n, 0));

  if (NCH(n) == 3) {
    optional_vars = ast_for_expr(c, CHILD(n, 2));
    setContext(c, optional_vars, Sk.astnodes.Store, n);
  }

  return new Sk.astnodes.withitem(context_expr, optional_vars);
}
/* with_stmt: 'with' with_item (',' with_item)* ':' suite */


function ast_for_with_stmt(c, n0, is_async) {
  var n = is_async ? CHILD(n0, 1) : n0;
  var i;
  var items = [],
      body;
  REQ(n, SYM.with_stmt);

  for (i = 1; i < NCH(n) - 2; i += 2) {
    var item = ast_for_with_item(c, CHILD(n, i));
    items[(i - 1) / 2] = item;
  }

  body = astForSuite(c, CHILD(n, NCH(n) - 1));

  if (is_async) {
    return new Sk.astnodes.AsyncWith(items, body, LINENO(n0), n0.col_offset, n0.end_lineno, n0.end_col_offset);
  } else {
    return new Sk.astnodes.With(items, body, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  }
}

function astForExecStmt(c, n) {
  var expr1,
      globals = null,
      locals = null;
  var nchildren = NCH(n);
  Sk.asserts.assert(nchildren === 2 || nchildren === 4 || nchildren === 6);
  /* exec_stmt: 'exec' expr ['in' test [',' test]] */

  REQ(n, SYM.exec_stmt);
  expr1 = ast_for_expr(c, CHILD(n, 1));

  if (nchildren >= 4) {
    globals = ast_for_expr(c, CHILD(n, 3));
  }

  if (nchildren === 6) {
    locals = ast_for_expr(c, CHILD(n, 5));
  }

  return new Sk.astnodes.Exec(expr1, globals, locals, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForIfStmt(c, n) {
  /* if_stmt: 'if' test ':' suite ('elif' test ':' suite)*
   ['else' ':' suite]
   */
  var off;
  var i;
  var orelse;
  var hasElse;
  var nElif;
  var decider;
  var s;
  REQ(n, SYM.if_stmt);

  if (NCH(n) === 4) {
    return new Sk.astnodes.If(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  s = CHILD(n, 4).value;
  decider = s.charAt(2); // elSe or elIf

  if (decider === "s") {
    return new Sk.astnodes.If(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (decider === "i") {
    nElif = NCH(n) - 4;
    hasElse = false;
    orelse = [];
    /* must reference the child nElif+1 since 'else' token is third, not
     * fourth child from the end. */

    if (CHILD(n, nElif + 1).type === TOK.T_NAME && CHILD(n, nElif + 1).value.charAt(2) === "s") {
      hasElse = true;
      nElif -= 3;
    }

    nElif /= 4;

    if (hasElse) {
      orelse = [new Sk.astnodes.If(ast_for_expr(c, CHILD(n, NCH(n) - 6)), astForSuite(c, CHILD(n, NCH(n) - 4)), astForSuite(c, CHILD(n, NCH(n) - 1)), CHILD(n, NCH(n) - 6).lineno, CHILD(n, NCH(n) - 6).col_offset, CHILD(n, NCH(n) - 6).end_lineno, CHILD(n, NCH(n) - 6).end_col_offset)];
      nElif--;
    }

    for (i = 0; i < nElif; ++i) {
      off = 5 + (nElif - i - 1) * 4;
      orelse = [new Sk.astnodes.If(ast_for_expr(c, CHILD(n, off)), astForSuite(c, CHILD(n, off + 2)), orelse, CHILD(n, off).lineno, CHILD(n, off).col_offset, CHILD(n, NCH(n) - 6).end_lineno, CHILD(n, NCH(n) - 6).end_col_offset)];
    }

    return new Sk.astnodes.If(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), orelse, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  Sk.asserts.fail("unexpected token in 'if' statement");
}

function ast_for_exprlist(c, n, context) {
  var e;
  var i;
  var seq;
  REQ(n, SYM.exprlist);
  seq = [];

  for (i = 0; i < NCH(n); i += 2) {
    e = ast_for_expr(c, CHILD(n, i));
    seq[i / 2] = e;

    if (context) {
      setContext(c, e, context, CHILD(n, i));
    }
  }

  return seq;
}

function astForDelStmt(c, n) {
  /* del_stmt: 'del' exprlist */
  REQ(n, SYM.del_stmt);
  return new Sk.astnodes.Delete(ast_for_exprlist(c, CHILD(n, 1), Sk.astnodes.Del), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForGlobalStmt(c, n) {
  /* global_stmt: 'global' NAME (',' NAME)* */
  var i;
  var s = [];
  REQ(n, SYM.global_stmt);

  for (i = 1; i < NCH(n); i += 2) {
    s[(i - 1) / 2] = strobj(CHILD(n, i).value);
  }

  return new Sk.astnodes.Global(s, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForAssertStmt(c, n) {
  /* assert_stmt: 'assert' test [',' test] */
  REQ(n, SYM.assert_stmt);

  if (NCH(n) === 2) {
    return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), null, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (NCH(n) === 4) {
    return new Sk.astnodes.Assert(ast_for_expr(c, CHILD(n, 1)), ast_for_expr(c, CHILD(n, 3)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  Sk.asserts.fail("improper number of parts to assert stmt");
}

function aliasForImportName(c, n) {
  /*
   import_as_name: NAME ['as' NAME]
   dotted_as_name: dotted_name ['as' NAME]
   dotted_name: NAME ('.' NAME)*
   */
  var i;
  var a;
  var name;
  var str;

  loop: while (true) {
    switch (n.type) {
      case SYM.import_as_name:
        str = null;
        name = strobj(CHILD(n, 0).value);

        if (NCH(n) === 3) {
          str = CHILD(n, 2).value;
        }

        return new Sk.astnodes.alias(name, str == null ? null : strobj(str));

      case SYM.dotted_as_name:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue loop;
        } else {
          a = aliasForImportName(c, CHILD(n, 0));
          Sk.asserts.assert(!a.asname);
          a.asname = strobj(CHILD(n, 2).value);
          return a;
        }

        break;

      case SYM.dotted_name:
        if (NCH(n) === 1) {
          return new Sk.astnodes.alias(strobj(CHILD(n, 0).value), null);
        } else {
          // create a string of the form a.b.c
          str = "";

          for (i = 0; i < NCH(n); i += 2) {
            str += CHILD(n, i).value + ".";
          }

          return new Sk.astnodes.alias(strobj(str.substr(0, str.length - 1)), null);
        }

        break;

      case TOK.T_STAR:
        return new Sk.astnodes.alias(strobj("*"), null);

      default:
        throw new Sk.builtin.SyntaxError("unexpected import name", c.c_filename, n.lineno);
    }

    break;
  }
}

function astForImportStmt(c, n) {
  /*
   import_stmt: import_name | import_from
   import_name: 'import' dotted_as_names
   import_from: 'from' ('.'* dotted_name | '.') 'import'
   ('*' | '(' import_as_names ')' | import_as_names)
   */
  var modname;
  var idx;
  var nchildren;
  var ndots;
  var mod;
  var i;
  var aliases;
  var col_offset;
  var lineno;
  var end_lineno;
  var end_col_offset;
  REQ(n, SYM.import_stmt);
  lineno = n.lineno;
  col_offset = n.col_offset;
  end_lineno = n.end_lineno;
  end_col_offset = n.end_col_offset;
  n = CHILD(n, 0);

  if (n.type === SYM.import_name) {
    n = CHILD(n, 1);
    REQ(n, SYM.dotted_as_names);
    aliases = [];

    for (i = 0; i < NCH(n); i += 2) {
      aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
    }

    return new Sk.astnodes.Import(aliases, lineno, col_offset, end_lineno, end_col_offset);
  } else if (n.type === SYM.import_from) {
    mod = null;
    ndots = 0;

    for (idx = 1; idx < NCH(n); ++idx) {
      if (CHILD(n, idx).type === SYM.dotted_name) {
        mod = aliasForImportName(c, CHILD(n, idx));
        idx++;
        break;
      } else if (CHILD(n, idx).type === TOK.T_DOT) {
        ndots++;
      } else if (CHILD(n, idx).type === TOK.T_ELLIPSIS) {
        ndots += 3;
      } else {
        break;
      }
    }

    ++idx; // skip the import keyword

    switch (CHILD(n, idx).type) {
      case TOK.T_STAR:
        // from ... import
        n = CHILD(n, idx);
        nchildren = 1;
        break;

      case TOK.T_LPAR:
        // from ... import (x, y, z)
        n = CHILD(n, idx + 1);
        nchildren = NCH(n);
        break;

      case SYM.import_as_names:
        // from ... import x, y, z
        n = CHILD(n, idx);
        nchildren = NCH(n);

        if (nchildren % 2 === 0) {
          throw new Sk.builtin.SyntaxError("trailing comma not allowed without surrounding parentheses", c.c_filename, n.lineno);
        }

        break;

      default:
        throw new Sk.builtin.SyntaxError("Unexpected node-type in from-import", c.c_filename, n.lineno);
    }

    aliases = [];

    if (n.type === TOK.T_STAR) {
      aliases[0] = aliasForImportName(c, n);
    } else {
      for (i = 0; i < NCH(n); i += 2) {
        aliases[i / 2] = aliasForImportName(c, CHILD(n, i));
      }
    }

    modname = mod ? mod.name.v : "";
    return new Sk.astnodes.ImportFrom(strobj(modname), aliases, ndots, lineno, col_offset, end_lineno, end_col_offset);
  }

  throw new Sk.builtin.SyntaxError("unknown import statement", c.c_filename, n.lineno);
}

function ast_for_testlistComp(c, n) {
  /* testlist_comp: test ( comp_for | (',' test)* [','] ) */

  /* argument: test [comp_for] */
  Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);

  if (NCH(n) > 1 && CHILD(n, 1).type === SYM.comp_for) {
    return ast_for_gen_expr(c, n);
  }

  return ast_for_testlist(c, n);
}

function ast_for_genexp(c, n) {
  Sk.asserts.assert(TYPE(n) == SYM.testlist_comp || TYPE(n) == SYM.argument);
  return ast_for_itercomp(c, n, COMP_GENEXP);
}

function ast_for_listcomp(c, n) {
  Sk.asserts.assert(TYPE(n) == SYM.testlist_comp);
  return ast_for_itercomp(c, n, COMP_LISTCOMP);
}

function astForFactor(c, n) {
  /* some random peephole thing that cpy does */
  var expression;
  var pnum;
  var patom;
  var ppower;
  var pfactor;

  if (CHILD(n, 0).type === TOK.T_MINUS && NCH(n) === 2) {
    pfactor = CHILD(n, 1);

    if (pfactor.type === SYM.factor && NCH(pfactor) === 1) {
      ppower = CHILD(pfactor, 0);

      if (ppower.type === SYM.power && NCH(ppower) === 1) {
        patom = CHILD(ppower, 0);

        if (patom.type === SYM.atom) {
          pnum = CHILD(patom, 0);

          if (pnum.type === TOK.T_NUMBER) {
            pnum.value = "-" + pnum.value;
            return ast_for_atom(c, patom);
          }
        }
      }
    }
  }

  expression = ast_for_expr(c, CHILD(n, 1));

  switch (CHILD(n, 0).type) {
    case TOK.T_PLUS:
      return new Sk.astnodes.UnaryOp(Sk.astnodes.UAdd, expression, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_MINUS:
      return new Sk.astnodes.UnaryOp(Sk.astnodes.USub, expression, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_TILDE:
      return new Sk.astnodes.UnaryOp(Sk.astnodes.Invert, expression, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  Sk.asserts.fail("unhandled factor");
}

function astForForStmt(c, n) {
  /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */
  var target;

  var _target;

  var nodeTarget;
  var seq = [];
  REQ(n, SYM.for_stmt);

  if (NCH(n) === 9) {
    seq = astForSuite(c, CHILD(n, 8));
  }

  nodeTarget = CHILD(n, 1);
  _target = ast_for_exprlist(c, nodeTarget, Sk.astnodes.Store);

  if (NCH(nodeTarget) === 1) {
    target = _target[0];
  } else {
    target = new Sk.astnodes.Tuple(_target, Sk.astnodes.Store, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  return new Sk.astnodes.For(target, ast_for_testlist(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 5)), seq, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function ast_for_call(c, n, func, allowgen) {
  /*
    arglist: argument (',' argument)*  [',']
    argument: ( test [comp_for] | '*' test | test '=' test | '**' test )
  */
  var i, nargs, nkeywords;
  var ndoublestars;
  var args;
  var keywords;
  REQ(n, SYM.arglist);
  nargs = 0;
  nkeywords = 0;

  for (i = 0; i < NCH(n); i++) {
    var ch = CHILD(n, i);

    if (TYPE(ch) == SYM.argument) {
      if (NCH(ch) == 1) {
        nargs++;
      } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
        nargs++;

        if (!allowgen) {
          ast_error(c, ch, "invalid syntax");
        }

        if (NCH(n) > 1) {
          ast_error(c, ch, "Generator expression must be parenthesized");
        }
      } else if (TYPE(CHILD(ch, 0)) == TOK.T_STAR) {
        nargs++;
      } else {
        /* TYPE(CHILD(ch, 0)) == DOUBLESTAR or keyword argument */
        nkeywords++;
      }
    }
  }

  args = [];
  keywords = [];
  nargs = 0;
  /* positional arguments + iterable argument unpackings */

  nkeywords = 0;
  /* keyword arguments + keyword argument unpackings */

  ndoublestars = 0;
  /* just keyword argument unpackings */

  for (i = 0; i < NCH(n); i++) {
    ch = CHILD(n, i);

    if (TYPE(ch) == SYM.argument) {
      var e;
      var chch = CHILD(ch, 0);

      if (NCH(ch) == 1) {
        /* a positional argument */
        if (nkeywords) {
          if (ndoublestars) {
            ast_error(c, chch, "positional argument follows " + "keyword argument unpacking");
          } else {
            ast_error(c, chch, "positional argument follows " + "keyword argument");
          }
        }

        e = ast_for_expr(c, chch);

        if (!e) {
          return NULL;
        }

        args[nargs++] = e;
      } else if (TYPE(chch) == TOK.T_STAR) {
        /* an iterable argument unpacking */
        var starred;

        if (ndoublestars) {
          ast_error(c, chch, "iterable argument unpacking follows " + "keyword argument unpacking");
          return NULL;
        }

        e = ast_for_expr(c, CHILD(ch, 1));

        if (!e) {
          return NULL;
        }

        starred = new Sk.astnodes.Starred(e, Sk.astnodes.Load, LINENO(chch), chch.col_offset, chch.end_lineno, chch.end_col_offset);
        args[nargs++] = starred;
      } else if (TYPE(chch) == TOK.T_DOUBLESTAR) {
        /* a keyword argument unpacking */
        var kw;
        i++;
        e = ast_for_expr(c, CHILD(ch, 1));

        if (!e) {
          return NULL;
        }

        kw = new Sk.astnodes.keyword(NULL, e);
        keywords[nkeywords++] = kw;
        ndoublestars++;
      } else if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
        /* the lone generator expression */
        e = ast_for_genexp(c, ch);

        if (!e) {
          return NULL;
        }

        args[nargs++] = e;
      } else {
        /* a keyword argument */
        var kw;
        var key, tmp;
        var k;
        /* chch is test, but must be an identifier? */

        e = ast_for_expr(c, chch);

        if (!e) {
          return NULL;
        }
        /* f(lambda x: x[0] = 3) ends up getting parsed with
         * LHS test = lambda x: x[0], and RHS test = 3.
         * SF bug 132313 points out that complaining about a keyword
         * then is very confusing.
         */


        if (e.constructor === Sk.astnodes.Lambda) {
          ast_error(c, chch, "lambda cannot contain assignment");
          return NULL;
        } else if (e.constructor !== Sk.astnodes.Name) {
          ast_error(c, chch, "keyword can't be an expression");
          return NULL;
        } else if (forbiddenCheck(c, e.id, ch, 1)) {
          return NULL;
        }

        key = e.id;

        for (k = 0; k < nkeywords; k++) {
          tmp = keywords[k].arg;

          if (tmp && tmp === key) {
            ast_error(c, chch, "keyword argument repeated");
            return NULL;
          }
        }

        e = ast_for_expr(c, CHILD(ch, 2));
        if (!e) return NULL;
        kw = new Sk.astnodes.keyword(key, e);
        keywords[nkeywords++] = kw;
      }
    }
  }

  return new Sk.astnodes.Call(func, args, keywords, func.lineno, func.col_offset, func.end_lineno, func.end_col_offset);
}

function ast_for_trailer(c, n, left_expr) {
  /* trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
     subscriptlist: subscript (',' subscript)* [',']
     subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
   */
  REQ(n, SYM.trailer);

  if (TYPE(CHILD(n, 0)) == TOK.T_LPAR) {
    if (NCH(n) == 2) return new Sk.astnodes.Call(left_expr, NULL, NULL, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);else return ast_for_call(c, CHILD(n, 1), left_expr, true);
  } else if (TYPE(CHILD(n, 0)) == TOK.T_DOT) {
    var attr_id = new_identifier(CHILD(n, 1));
    if (!attr_id) return NULL;
    return new Sk.astnodes.Attribute(left_expr, attr_id, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  } else {
    REQ(CHILD(n, 0), TOK.T_LSQB);
    REQ(CHILD(n, 2), TOK.T_RSQB);
    n = CHILD(n, 1);

    if (NCH(n) == 1) {
      var slc = astForSlice(c, CHILD(n, 0));

      if (!slc) {
        return NULL;
      }

      return new Sk.astnodes.Subscript(left_expr, slc, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
    } else {
      /* The grammar is ambiguous here. The ambiguity is resolved
         by treating the sequence as a tuple literal if there are
         no slice features.
      */
      var j;
      var slc;
      var e;
      var simple = 1;
      var slices = [],
          elts;

      for (j = 0; j < NCH(n); j += 2) {
        slc = astForSlice(c, CHILD(n, j));

        if (!slc) {
          return NULL;
        }

        if (slc.kind != _slice_kind.Index_kind) {
          simple = 0;
        }

        slices[j / 2] = slc;
      }

      if (!simple) {
        return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.ExtSlice(slices), Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }
      /* extract Index values and put them in a Tuple */


      elts = [];

      for (j = 0; j < slices.length; ++j) {
        // @meredydd any idea how we reach this?
        slc = slices[j];
        Sk.asserts.assert(slc.kind == _slice_kind.Index_kind && slc.v.Index.value);
        elts[j] = slc.v.Index.value;
      }

      e = new Sk.astnodes.Tuple(elts, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      return new Sk.astnodes.Subscript(left_expr, new Sk.astnodes.Index(e), Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
    }
  }
}

function ast_for_flow_stmt(c, n) {
  /*
    flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt
               | yield_stmt
    break_stmt: 'break'
    continue_stmt: 'continue'
    return_stmt: 'return' [testlist]
    yield_stmt: yield_expr
    yield_expr: 'yield' testlist | 'yield' 'from' test
    raise_stmt: 'raise' [test [',' test [',' test]]]
  */
  var ch;
  REQ(n, SYM.flow_stmt);
  ch = CHILD(n, 0);

  switch (TYPE(ch)) {
    case SYM.break_stmt:
      return new Sk.astnodes.Break(LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);

    case SYM.continue_stmt:
      return new Sk.astnodes.Continue(LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);

    case SYM.yield_stmt:
      {
        /* will reduce to yield_expr */
        var exp = ast_for_expr(c, CHILD(ch, 0));

        if (!exp) {
          return null;
        }

        return new Sk.astnodes.Expr(exp, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }

    case SYM.return_stmt:
      if (NCH(ch) == 1) return new Sk.astnodes.Return(null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);else {
        var expression = ast_for_testlist(c, CHILD(ch, 1));

        if (!expression) {
          return null;
        }

        return new Sk.astnodes.Return(expression, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }

    case SYM.raise_stmt:
      // This is tricky and Skulpt-specific, because we need to handle
      // both Python 3-style and Python 2-style 'raise' statements
      if (NCH(ch) == 1) return new Sk.astnodes.Raise(null, null, null, null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);else if (NCH(ch) >= 2) {
        var cause = null;
        var expression = ast_for_expr(c, CHILD(ch, 1));
        var inst = null,
            tback = null; // raise [expression] from [cause]

        if (NCH(ch) == 4 && CHILD(ch, 2).value == 'from') {
          if (!Sk.__future__.python3) {
            ast_error(c, CHILD(ch, 2), "raise ... from ... is not available in Python 2");
          }

          cause = ast_for_expr(c, CHILD(ch, 3));
        } else if (NCH(ch) >= 4 && CHILD(ch, 2).value == ',') {
          if (Sk.__future__.python3) {
            ast_error(c, n, "Old raise syntax is not available in Python 3");
          } // raise [exception_type], [instantiation value] [, [traceback]]
          // NB traceback isn't implemented in Skulpt yet


          inst = ast_for_expr(c, CHILD(ch, 3));

          if (NCH(ch) == 6) {
            tback = ast_for_expr(c, CHILD(ch, 5));
          }
        }

        return new Sk.astnodes.Raise(expression, cause, inst, tback, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }

    /* fall through */

    default:
      Sk.asserts.fail("unexpected flow_stmt: ", TYPE(ch));
      return null;
  }
}

function astForArg(c, n) {
  var name;
  var annotation = null;
  var ch;
  Sk.asserts.assert(n.type === SYM.tfpdef || n.type === SYM.vfpdef);
  ch = CHILD(n, 0);
  forbiddenCheck(c, ch, ch.value, ch.lineno);
  name = strobj(ch.value);

  if (NCH(n) == 3 && CHILD(n, 1).type === TOK.T_COLON) {
    annotation = ast_for_expr(c, CHILD(n, 2));
  }

  return new Sk.astnodes.arg(name, annotation, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}
/* returns -1 if failed to handle keyword only arguments
   returns new position to keep processing if successful
               (',' tfpdef ['=' test])*
                     ^^^
   start pointing here
 */


function handleKeywordonlyArgs(c, n, start, kwonlyargs, kwdefaults) {
  var argname;
  var ch;
  var expression;
  var annotation;
  var arg;
  var i = start;
  var j = 0;
  /* index for kwdefaults and kwonlyargs */

  if (!kwonlyargs) {
    ast_error(c, CHILD(n, start), "named arguments must follow bare *");
  }

  Sk.asserts.assert(kwdefaults);

  while (i < NCH(n)) {
    ch = CHILD(n, i);

    switch (ch.type) {
      case SYM.vfpdef:
      case SYM.tfpdef:
        if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {
          kwdefaults[j] = ast_for_expr(c, CHILD(n, i + 2));
          i += 2;
          /* '=' and test */
        } else {
          /* setting NULL if no default value exists */
          kwdefaults[j] = null;
        }

        if (NCH(ch) == 3) {
          /* ch is NAME ':' test */
          annotation = ast_for_expr(c, CHILD(ch, 2));
        } else {
          annotation = null;
        }

        ch = CHILD(ch, 0);
        forbiddenCheck(c, ch, ch.value, ch.lineno);
        argname = strobj(ch.value);
        kwonlyargs[j++] = new Sk.astnodes.arg(argname, annotation, ch.lineno, ch.col_offset, ch.end_lineno, ch.end_col_offset);
        i += 2;
        /* the name and the comma */

        break;

      case TOK.T_DOUBLESTAR:
        return i;

      default:
        ast_error(c, ch, "unexpected node");
    }
  }

  return i;
}

function astForArguments(c, n) {
  var k;
  var j;
  var i;
  var foundDefault;
  var posargs = [];
  var posdefaults = [];
  var kwonlyargs = [];
  var kwdefaults = [];
  var vararg = null;
  var kwarg = null;
  var ch = null;
  /* This function handles both typedargslist (function definition)
     and varargslist (lambda definition).
      parameters: '(' [typedargslist] ')'
     typedargslist: (tfpdef ['=' test] (',' tfpdef ['=' test])* [',' [
             '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
           | '**' tfpdef [',']]]
       | '*' [tfpdef] (',' tfpdef ['=' test])* [',' ['**' tfpdef [',']]]
       | '**' tfpdef [','])
     tfpdef: NAME [':' test]
     varargslist: (vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [
             '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
           | '**' vfpdef [',']]]
       | '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
       | '**' vfpdef [',']
     )
     vfpdef: NAME
   */

  if (n.type === SYM.parameters) {
    if (NCH(n) === 2) // () as arglist
      {
        return new Sk.astnodes.arguments_([], null, [], [], null, []);
      }

    n = CHILD(n, 1);
  }

  Sk.asserts.assert(n.type === SYM.varargslist || n.type === SYM.typedargslist); // Skulpt note: the "counting numbers of args" section
  // from ast.c is omitted because JS arrays autoexpand

  /* tfpdef: NAME [':' test]
     vfpdef: NAME
  */

  i = 0;
  j = 0;
  /* index for defaults */

  k = 0;
  /* index for args */

  while (i < NCH(n)) {
    ch = CHILD(n, i);

    switch (ch.type) {
      case SYM.tfpdef:
      case SYM.vfpdef:
        /* XXX Need to worry about checking if TYPE(CHILD(n, i+1)) is
           anything other than EQUAL or a comma? */

        /* XXX Should NCH(n) check be made a separate check? */
        if (i + 1 < NCH(n) && CHILD(n, i + 1).type == TOK.T_EQUAL) {
          posdefaults[j++] = ast_for_expr(c, CHILD(n, i + 2));
          i += 2;
          foundDefault = 1;
        } else if (foundDefault) {
          throw new Sk.builtin.SyntaxError("non-default argument follows default argument", c.c_filename, n.lineno);
        }

        posargs[k++] = astForArg(c, ch);
        i += 2;
        /* the name and the comma */

        break;

      case TOK.T_STAR:
        if (i + 1 >= NCH(n) || i + 2 == NCH(n) && CHILD(n, i + 1).type == TOK.T_COMMA) {
          throw new Sk.builtin.SyntaxError("named arguments must follow bare *", c.c_filename, n.lineno);
        }

        ch = CHILD(n, i + 1);
        /* tfpdef or COMMA */

        if (ch.type == TOK.T_COMMA) {
          i += 2;
          /* now follows keyword only arguments */

          i = handleKeywordonlyArgs(c, n, i, kwonlyargs, kwdefaults);
        } else {
          vararg = astForArg(c, ch);
          i += 3;

          if (i < NCH(n) && (CHILD(n, i).type == SYM.tfpdef || CHILD(n, i).type == SYM.vfpdef)) {
            i = handleKeywordonlyArgs(c, n, i, kwonlyargs, kwdefaults);
          }
        }

        break;

      case TOK.T_DOUBLESTAR:
        ch = CHILD(n, i + 1);
        /* tfpdef */

        Sk.asserts.assert(ch.type == SYM.tfpdef || ch.type == SYM.vfpdef);
        kwarg = astForArg(c, ch);
        i += 3;
        break;

      default:
        Sk.asserts.fail("unexpected node in varargslist");
        return;
    }
  }

  return new Sk.astnodes.arguments_(posargs, vararg, kwonlyargs, kwdefaults, kwarg, posdefaults);
}

function ast_for_async_funcdef(c, n, decorator_seq) {
  /* async_funcdef: 'async' funcdef */
  REQ(n, SYM.async_funcdef);
  REQ(CHILD(n, 0), TOK.T_NAME);
  Sk.asserts.assert(STR(CHILD(n, 0) === "async"));
  REQ(CHILD(n, 1), SYM.funcdef);
  return ast_for_funcdef_impl(c, n, decorator_seq, true
  /* is_async */
  );
}

function ast_for_funcdef(c, n, decorator_seq) {
  /* funcdef: 'def' NAME parameters ['->' test] ':' suite */
  return ast_for_funcdef_impl(c, n, decorator_seq, false
  /* is_async */
  );
}

function ast_for_funcdef_impl(c, n0, decorator_seq, is_async) {
  /* funcdef: 'def' NAME parameters ['->' test] ':' [TYPE_COMMENT] suite */
  var n = is_async ? CHILD(n0, 1) : n0;
  var name;
  var args;
  var body;
  var returns = NULL;
  var name_i = 1;
  var end_lineno, end_col_offset;
  var tc;
  var type_comment = NULL;

  if (is_async && c.c_feature_version < 5) {
    ast_error(c, n, "Async functions are only supported in Python 3.5 and greater");
    return NULL;
  }

  REQ(n, SYM.funcdef);
  name = new_identifier(CHILD(n, name_i));

  if (forbiddenCheck(c, name, CHILD(n, name_i), 0)) {
    return NULL;
  }

  args = astForArguments(c, CHILD(n, name_i + 1));

  if (!args) {
    return NULL;
  }

  if (TYPE(CHILD(n, name_i + 2)) == TOK.T_RARROW) {
    returns = ast_for_expr(c, CHILD(n, name_i + 3));

    if (!returns) {
      return NULL;
    }

    name_i += 2;
  }

  if (TYPE(CHILD(n, name_i + 3)) == TOK.T_TYPE_COMMENT) {
    type_comment = TOK.T_NEW_TYPE_COMMENT(CHILD(n, name_i + 3));
    if (!type_comment) return NULL;
    name_i += 1;
  }

  body = astForSuite(c, CHILD(n, name_i + 3));

  if (!body) {
    return NULL;
  } // get_last_end_pos(body, &end_lineno, &end_col_offset);


  if (NCH(CHILD(n, name_i + 3)) > 1) {
    /* Check if the suite has a type comment in it. */
    tc = CHILD(CHILD(n, name_i + 3), 1);

    if (TYPE(tc) == TOK.T_TYPE_COMMENT) {
      if (type_comment != NULL) {
        ast_error(c, n, "Cannot have two type comments on def");
        return NULL;
      }

      type_comment = TOK.T_NEW_TYPE_COMMENT(tc);
      if (!type_comment) return NULL;
    }
  }

  if (is_async) return new Sk.astnodes.AsyncFunctionDef(name, args, body, decorator_seq, returns, type_comment, LINENO(n0), n0.col_offset, n0.end_lineno, n0.end_col_offset);else return new Sk.astnodes.FunctionDef(name, args, body, decorator_seq, returns, type_comment, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForClassBases(c, n) {
  /* testlist: test (',' test)* [','] */
  Sk.asserts.assert(NCH(n) > 0);
  REQ(n, SYM.testlist);

  if (NCH(n) === 1) {
    return [ast_for_expr(c, CHILD(n, 0))];
  }

  return seq_for_testlist(c, n);
}

function astForClassdef(c, n, decoratorSeq) {
  /* classdef: 'class' NAME ['(' arglist ')'] ':' suite */
  var classname;
  var call;
  var s;
  REQ(n, SYM.classdef);

  if (NCH(n) == 4) {
    /* class NAME ':' suite */
    s = astForSuite(c, CHILD(n, 3));
    classname = new_identifier(CHILD(n, 1).value);
    forbiddenCheck(c, CHILD(n, 3), classname, n.lineno);
    return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,
    /*TODO docstring*/
    null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  }

  if (TYPE(CHILD(n, 3)) === TOK.T_RPAR) {
    /* class NAME '(' ')' ':' suite */
    s = astForSuite(c, CHILD(n, 5));
    classname = new_identifier(CHILD(n, 1).value);
    forbiddenCheck(c, CHILD(n, 3), classname, CHILD(n, 3).lineno);
    return new Sk.astnodes.ClassDef(classname, [], [], s, decoratorSeq,
    /*TODO docstring*/
    null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  }
  /* class NAME '(' arglist ')' ':' suite */

  /* build up a fake Call node so we can extract its pieces */


  {
    var dummy_name;
    var dummy;
    dummy_name = new_identifier(CHILD(n, 1));
    dummy = new Sk.astnodes.Name(dummy_name, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
    call = ast_for_call(c, CHILD(n, 3), dummy, false);
  }
  s = astForSuite(c, CHILD(n, 6));
  classname = new_identifier(CHILD(n, 1).value);
  forbiddenCheck(c, CHILD(n, 1), classname, CHILD(n, 1).lineno);
  return new Sk.astnodes.ClassDef(classname, call.args, call.keywords, s, decoratorSeq,
  /*TODO docstring*/
  null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForLambdef(c, n) {
  /* lambdef: 'lambda' [varargslist] ':' test */
  var args;
  var expression;

  if (NCH(n) === 3) {
    args = new Sk.astnodes.arguments_([], null, null, []);
    expression = ast_for_expr(c, CHILD(n, 2));
  } else {
    args = astForArguments(c, CHILD(n, 1));
    expression = ast_for_expr(c, CHILD(n, 3));
  }

  return new Sk.astnodes.Lambda(args, expression, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForComprehension(c, n) {
  /* testlist_comp: test ( comp_for | (',' test)* [','] )
     argument: test [comp_for] | test '=' test       # Really [keyword '='] test */
  var j;
  var ifs;
  var nifs;
  var ge;
  var expression;
  var t;
  var forch;
  var i;
  var ch;
  var genexps;
  var nfors;
  var elt;
  var comps;
  var comp;

  function countCompFors(c, n) {
    var nfors = 0;

    count_comp_for: while (true) {
      nfors++;
      REQ(n, SYM.comp_for);

      if (NCH(n) === 5) {
        n = CHILD(n, 4);
      } else {
        return nfors;
      }

      count_comp_iter: while (true) {
        REQ(n, SYM.comp_iter);
        n = CHILD(n, 0);

        if (n.type === SYM.comp_for) {
          continue count_comp_for;
        } else if (n.type === SYM.comp_if) {
          if (NCH(n) === 3) {
            n = CHILD(n, 2);
            continue count_comp_iter;
          } else {
            return nfors;
          }
        }

        break;
      }

      break;
    }

    Sk.asserts.fail("logic error in countCompFors");
  }

  function countCompIfs(c, n) {
    var nifs = 0;

    while (true) {
      REQ(n, SYM.comp_iter);

      if (CHILD(n, 0).type === SYM.comp_for) {
        return nifs;
      }

      n = CHILD(n, 0);
      REQ(n, SYM.comp_if);
      nifs++;

      if (NCH(n) === 2) {
        return nifs;
      }

      n = CHILD(n, 2);
    }
  }

  nfors = countCompFors(c, n);
  comps = [];

  for (i = 0; i < nfors; ++i) {
    REQ(n, SYM.comp_for);
    forch = CHILD(n, 1);
    t = ast_for_exprlist(c, forch, Sk.astnodes.Store);
    expression = ast_for_expr(c, CHILD(n, 3));

    if (NCH(forch) === 1) {
      comp = new Sk.astnodes.comprehension(t[0], expression, []);
    } else {
      comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset), expression, []);
    }

    if (NCH(n) === 5) {
      n = CHILD(n, 4);
      nifs = countCompIfs(c, n);
      ifs = [];

      for (j = 0; j < nifs; ++j) {
        REQ(n, SYM.comp_iter);
        n = CHILD(n, 0);
        REQ(n, SYM.comp_if);
        expression = ast_for_expr(c, CHILD(n, 1));
        ifs[j] = expression;

        if (NCH(n) === 3) {
          n = CHILD(n, 2);
        }
      }

      if (n.type === SYM.comp_iter) {
        n = CHILD(n, 0);
      }

      comp.ifs = ifs;
    }

    comps[i] = comp;
  }

  return comps;
}

function astForIterComp(c, n, type) {
  var elt, comps;
  Sk.asserts.assert(NCH(n) > 1);
  elt = ast_for_expr(c, CHILD(n, 0));
  comps = astForComprehension(c, CHILD(n, 1));

  if (type === COMP_GENEXP) {
    return new Sk.astnodes.GeneratorExp(elt, comps, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (type === COMP_SETCOMP) {
    return new Sk.astnodes.SetComp(elt, comps, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }
}
/*
   Count the number of 'for' loops in a comprehension.
   Helper for ast_for_comprehension().
*/


function count_comp_fors(c, n) {
  var n_fors = 0;
  var is_async;

  count_comp_for: while (true) {
    // @meredydd needs new grammar
    // REQ(n, SYM.comp_for);
    // if (NCH(n) === 2) {
    //     REQ(CHILD(n, 0), TOK.T_ASYNC);
    //     n = CHILD(n, 1);
    // } else if (NCH(n) === 1) {
    //     n = CHILD(n, 0);
    // } else {
    //     Sk.asserts.fail("logic error in count_comp_fors");
    // }
    // if (NCH(n) == (5)) {
    //     n = CHILD(n, 4);
    // } else {
    //     return n_fors;
    // }
    is_async = 0;
    n_fors++;
    REQ(n, SYM.comp_for);

    if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {
      is_async = 1;
    }

    if (NCH(n) == 5 + is_async) {
      n = CHILD(n, 4 + is_async);
    } else {
      return n_fors;
    }

    count_comp_iter: while (true) {
      REQ(n, SYM.comp_iter);
      n = CHILD(n, 0);

      if (TYPE(n) === SYM.comp_for) {
        continue count_comp_for;
      } else if (TYPE(n) === SYM.comp_if) {
        if (NCH(n) === 3) {
          n = CHILD(n, 2);
          continue count_comp_iter;
        } else {
          return n_fors;
        }
      }

      break;
    }

    break;
  }
}

function count_comp_ifs(c, n) {
  var n_ifs = 0;

  while (true) {
    REQ(n, SYM.comp_iter);
    if (TYPE(CHILD(n, 0)) == SYM.comp_for) return n_ifs;
    n = CHILD(n, 0);
    REQ(n, SYM.comp_if);
    n_ifs++;

    if (NCH(n) == 2) {
      return n_ifs;
    }

    n = CHILD(n, 2);
  }
}

function ast_for_comprehension(c, n) {
  var i, n_fors;
  var comps = [];
  n_fors = count_comp_fors(c, n);

  for (i = 0; i < n_fors; i++) {
    var comp;
    var t;
    var expression, first;
    var for_ch;
    var is_async = 0;

    if (TYPE(CHILD(n, 0)) == TOK.T_ASYNC) {
      is_async = 1;
    }

    for_ch = CHILD(n, 1 + is_async);
    t = ast_for_exprlist(c, for_ch, Sk.astnodes.Store);

    if (!t) {
      return null;
    }

    expression = ast_for_expr(c, CHILD(n, 3 + is_async));

    if (!expression) {
      return null;
    } // again new grammar needed
    // REQ(n, SYM.comp_for);
    // if (NCH(n) == 2) {
    //     is_async = 1;
    //     REQ(CHILD(n, 0), TOK.T_ASYNC);
    //     sync_n = CHILD(n, 1);
    // }
    // else {
    //     sync_n = CHILD(n, 0);
    // }
    // REQ(sync_n, SYM.sync_comp_for);
    // /* Async comprehensions only allowed in Python 3.6 and greater */
    // /* @meredydd see below for the joys of the future! */
    // if (is_async && c.c_feature_version < 6) {
    //     ast_error(c, n,
    //               "Async comprehensions are only supported in Python 3.6 and greater");
    //     return null;
    // }
    // for_ch = CHILD(sync_n, 1);
    // t = ast_for_exprlist(c, for_ch, Sk.astnodes.Store);
    // expression = ast_for_expr(c, CHILD(sync_n, 3));

    /* Check the # of children rather than the length of t, since
       (x for x, in ...) has 1 element in t, but still requires a Tuple. */


    first = t[0];
    if (NCH(for_ch) == 1) comp = new Sk.astnodes.comprehension(first, expression, null, is_async);else comp = new Sk.astnodes.comprehension(new Sk.astnodes.Tuple(t, Sk.astnodes.Store, first.lineno, first.col_offset, for_ch.end_lineno, for_ch.end_col_offset), expression, null, is_async);

    if (NCH(n) == 5 + is_async) {
      var j, n_ifs;
      var ifs = [];
      n = CHILD(n, 4 + is_async);
      n_ifs = count_comp_ifs(c, n);

      if (n_ifs == -1) {
        return null;
      }

      for (j = 0; j < n_ifs; j++) {
        REQ(n, SYM.comp_iter);
        n = CHILD(n, 0);
        REQ(n, SYM.comp_if);
        expression = ast_for_expr(c, CHILD(n, 1));

        if (!expression) {
          return null;
        }

        ifs[j] = expression;

        if (NCH(n) == 3) {
          n = CHILD(n, 2);
        }
      }
      /* on exit, must guarantee that n is a comp_for */


      if (TYPE(n) == SYM.comp_iter) {
        n = CHILD(n, 0);
      }

      comp.ifs = ifs;
    } // if (NCH(sync_n) == 5) {
    //     var j, n_ifs;
    //     var ifs = [];
    //     n = CHILD(sync_n, 4);
    //     n_ifs = count_comp_ifs(c, n);
    //     for (j = 0; j < n_ifs; j++) {
    //         REQ(n, comp_iter);
    //         n = CHILD(n, 0);
    //         REQ(n, comp_if);
    //         expression = ast_for_expr(c, CHILD(n, 1));
    //         if (!expression) {
    //             return null;
    //         }
    //         ifs[j] = expression;
    //         if (NCH(n) == 3) {
    //             n = CHILD(n, 2);
    //         }
    //     }
    //     /* on exit, must guarantee that n is a comp_for */
    //     if (TYPE(n) == SYM.comp_iter) {
    //         n = CHILD(n, 0);
    //     }
    //     comp.ifs = ifs;
    // }


    comps[i] = comp;
  }

  return comps;
}

function ast_for_itercomp(c, n, type) {
  /* testlist_comp: (test|star_expr)
   *                ( comp_for | (',' (test|star_expr))* [','] ) */
  var elt;
  var comps;
  var ch;
  Sk.asserts.assert(NCH(n) > 1);
  ch = CHILD(n, 0);
  elt = ast_for_expr(c, ch);

  if (elt.constructor === Sk.astnodes.Starred) {
    ast_error(c, ch, "iterable unpacking cannot be used in comprehension");
    return NULL;
  }

  comps = ast_for_comprehension(c, CHILD(n, 1));

  if (type == COMP_GENEXP) {
    return new Sk.astnodes.GeneratorExp(elt, comps, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (type == COMP_LISTCOMP) {
    return new Sk.astnodes.ListComp(elt, comps, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (type == COMP_SETCOMP) {
    return new Sk.astnodes.SetComp(elt, comps, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
  } else {
    /* Should never happen */
    return null;
  }
}
/* Fills in the key, value pair corresponding to the dict element.  In case
 * of an unpacking, key is NULL.  *i is advanced by the number of ast
 * elements.  Iff successful, nonzero is returned.
 */


function ast_for_dictelement(c, n, i) {
  var expression;

  if (TYPE(CHILD(n, i)) == TOK.T_DOUBLESTAR) {
    Sk.asserts.assert(NCH(n) - i >= 2);
    expression = ast_for_expr(c, CHILD(n, i + 1));
    return {
      key: null,
      value: expression,
      i: i + 2
    };
  } else {
    Sk.asserts.assert(NCH(n) - i >= 3);
    expression = ast_for_expr(c, CHILD(n, i));
    if (!expression) return 0;
    var key = expression;
    REQ(CHILD(n, i + 1), TOK.T_COLON);
    expression = ast_for_expr(c, CHILD(n, i + 2));

    if (!expression) {
      return false;
    }

    var value = expression;
    return {
      key: key,
      value: value,
      i: i + 3
    };
  }
}

function ast_for_dictcomp(c, n) {
  var key, value;
  var comps = [];
  Sk.asserts.assert(NCH(n) > 3);
  REQ(CHILD(n, 1), TOK.T_COLON);
  key = ast_for_expr(c, CHILD(n, 0));
  value = ast_for_expr(c, CHILD(n, 2));
  comps = astForComprehension(c, CHILD(n, 3));
  return new Sk.astnodes.DictComp(key, value, comps, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function ast_for_dictdisplay(c, n) {
  var i;
  var j;
  var keys = [],
      values = [];
  j = 0;

  for (i = 0; i < NCH(n); i++) {
    var res = ast_for_dictelement(c, n, i);
    i = res.i;
    keys[j] = res.key;
    values[j] = res.value;
    j++;
  }

  return new Sk.astnodes.Dict(keys, values, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
}

function ast_for_gen_expr(c, n) {
  Sk.asserts.assert(n.type === SYM.testlist_comp || n.type === SYM.argument);
  return astForIterComp(c, n, COMP_GENEXP);
}

function ast_for_setcomp(c, n) {
  Sk.asserts.assert(n.type === SYM.dictorsetmaker);
  return astForIterComp(c, n, COMP_SETCOMP);
}

function astForWhileStmt(c, n) {
  /* while_stmt: 'while' test ':' suite ['else' ':' suite] */
  REQ(n, SYM.while_stmt);

  if (NCH(n) === 4) {
    return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), [], n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (NCH(n) === 7) {
    return new Sk.astnodes.While(ast_for_expr(c, CHILD(n, 1)), astForSuite(c, CHILD(n, 3)), astForSuite(c, CHILD(n, 6)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  Sk.asserts.fail("wrong number of tokens for 'while' stmt");
}

function astForAugassign(c, n) {
  REQ(n, SYM.augassign);
  n = CHILD(n, 0);

  switch (n.value.charAt(0)) {
    case "+":
      return Sk.astnodes.Add;

    case "-":
      return Sk.astnodes.Sub;

    case "/":
      if (n.value.charAt(1) === "/") {
        return Sk.astnodes.FloorDiv;
      }

      return Sk.astnodes.Div;

    case "%":
      return Sk.astnodes.Mod;

    case "<":
      return Sk.astnodes.LShift;

    case ">":
      return Sk.astnodes.RShift;

    case "&":
      return Sk.astnodes.BitAnd;

    case "^":
      return Sk.astnodes.BitXor;

    case "|":
      return Sk.astnodes.BitOr;

    case "*":
      if (n.value.charAt(1) === "*") {
        return Sk.astnodes.Pow;
      }

      return Sk.astnodes.Mult;

    case "@":
      if (Sk.__future__.python3) {
        return Sk.astnodes.MatMult;
      }

    default:
      Sk.asserts.fail("invalid augassign");
  }
}

function astForBinop(c, n) {
  /* Must account for a sequence of expressions.
   How should A op B op C by represented?
   BinOp(BinOp(A, op, B), op, C).
   */
  var tmp;
  var newoperator;
  var nextOper;
  var i;
  var result = new Sk.astnodes.BinOp(ast_for_expr(c, CHILD(n, 0)), getOperator(CHILD(n, 1)), ast_for_expr(c, CHILD(n, 2)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  var nops = (NCH(n) - 1) / 2;

  for (i = 1; i < nops; ++i) {
    nextOper = CHILD(n, i * 2 + 1);
    newoperator = getOperator(nextOper);
    tmp = ast_for_expr(c, CHILD(n, i * 2 + 2));
    result = new Sk.astnodes.BinOp(result, newoperator, tmp, nextOper.lineno, nextOper.col_offset, nextOper.end_lineno, nextOper.end_col_offset);
  }

  return result;
}

function ast_for_testlist(c, n) {
  /* testlist_comp: test (',' comp_for | (',' test)* [',']) */

  /* testlist: test (',' test)* [','] */
  Sk.asserts.assert(NCH(n) > 0);

  if (n.type === SYM.testlist_comp) {
    if (NCH(n) > 1) {
      Sk.asserts.assert(CHILD(n, 1).type !== SYM.comp_for);
    }
  } else {
    Sk.asserts.assert(n.type === SYM.testlist || n.type === SYM.testlist_star_expr);
  }

  if (NCH(n) === 1) {
    return ast_for_expr(c, CHILD(n, 0));
  } else {
    return new Sk.astnodes.Tuple(seq_for_testlist(c, n), Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
    /*, c.c_arena */
    );
  }
}

function ast_for_exprStmt(c, n) {
  var expression;
  var value;
  var e;
  var i;
  var targets;
  var expr2;
  var varName;
  var expr1;
  var ch;
  var deep;
  var ann;
  var simple;
  var expr3;
  REQ(n, SYM.expr_stmt);
  /* expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                          ('=' (yield_expr|testlist_star_expr))*)
     annassign: ':' test ['=' test]
     testlist_star_expr: (test|star_expr) (',' test|star_expr)* [',']
     augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^='
              | '<<=' | '>>=' | '**=' | '//='
     test: ... here starts the operator precedence dance
   */

  if (NCH(n) === 1) {
    return new Sk.astnodes.Expr(ast_for_testlist(c, CHILD(n, 0)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (CHILD(n, 1).type === SYM.augassign) {
    ch = CHILD(n, 0);
    expr1 = ast_for_testlist(c, ch);
    setContext(c, expr1, Sk.astnodes.Store, ch);

    switch (expr1.constructor) {
      case Sk.astnodes.Name:
        varName = expr1.id;
        forbiddenCheck(c, ch, varName, n.lineno);
        break;

      case Sk.astnodes.Attribute:
      case Sk.astnodes.Subscript:
        break;

      case Sk.astnodes.GeneratorExp:
        throw new Sk.builtin.SyntaxError("augmented assignment to generator expression not possible", c.c_filename, n.lineno);

      case Sk.astnodes.Yield:
        throw new Sk.builtin.SyntaxError("augmented assignment to yield expression not possible", c.c_filename, n.lineno);

      default:
        throw new Sk.builtin.SyntaxError("illegal expression for augmented assignment", c.c_filename, n.lineno);
    }

    ch = CHILD(n, 2);

    if (ch.type === SYM.testlist) {
      expr2 = ast_for_testlist(c, ch);
    } else {
      expr2 = ast_for_expr(c, ch);
    }

    return new Sk.astnodes.AugAssign(expr1, astForAugassign(c, CHILD(n, 1)), expr2, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  } else if (CHILD(n, 1).type === SYM.annassign) {
    if (!Sk.__future__.python3) {
      throw new Sk.builtin.SyntaxError("Annotated assignment is not supported in Python 2", c.c_filename, n.lineno);
    } // annotated assignment


    ch = CHILD(n, 0);
    ann = CHILD(n, 1);
    simple = 1;
    deep = ch;

    while (NCH(deep) == 1) {
      deep = CHILD(deep, 0);
    }

    if (NCH(deep) > 0 && TYPE(CHILD(deep, 0)) == TOK.T_LPAR) {
      simple = 0;
    }

    expr1 = ast_for_testlist(c, ch);

    switch (expr1.constructor) {
      case Sk.astnodes.Name:
        varName = expr1.id;
        forbiddenCheck(c, ch, varName, n.lineno);
        setContext(c, expr1, Sk.astnodes.Store, ch);
        break;

      case Sk.astnodes.Attribute:
        varName = expr1.attr;
        forbiddenCheck(c, ch, varName, n.lineno);
        setContext(c, expr1, Sk.astnodes.Store, ch);
        break;

      case Sk.astnodes.Subscript:
        setContext(c, expr1, Sk.astnodes.Store, ch);
        break;

      case Sk.astnodes.List:
        throw new Sk.builtin.SyntaxError("only single target (not list) can be annotated", c.c_filename, n.lineno);

      case Sk.astnodes.Tuple:
        throw new Sk.builtin.SyntaxError("only single target (not tuple) can be annotated", c.c_filename, n.lineno);

      default:
        throw new Sk.builtin.SyntaxError("illegal target for annotation", c.c_filename, n.lineno);
    }

    if (expr1.constructor != Sk.astnodes.Name) {
      simple = 0;
    }

    ch = CHILD(ann, 1);
    expr2 = ast_for_expr(c, ch);

    if (NCH(ann) == 2) {
      return new Sk.astnodes.AnnAssign(expr1, expr2, null, simple, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
    } else {
      ch = CHILD(ann, 3);
      expr3 = ast_for_expr(c, ch);
      return new Sk.astnodes.AnnAssign(expr1, expr2, expr3, simple, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
    }
  } else {
    // normal assignment
    REQ(CHILD(n, 1), TOK.T_EQUAL);
    targets = [];

    for (i = 0; i < NCH(n) - 2; i += 2) {
      ch = CHILD(n, i);

      if (ch.type === SYM.yield_expr) {
        throw new Sk.builtin.SyntaxError("assignment to yield expression not possible", c.c_filename, n.lineno);
      }

      e = ast_for_testlist(c, ch);
      setContext(c, e, Sk.astnodes.Store, CHILD(n, i));
      targets[i / 2] = e;
    }

    value = CHILD(n, NCH(n) - 1);

    if (value.type === SYM.testlist_star_expr) {
      expression = ast_for_testlist(c, value);
    } else {
      expression = ast_for_expr(c, value);
    }

    return new Sk.astnodes.Assign(targets, expression, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }
}

function astForIfexpr(c, n) {
  /* test: or_test 'if' or_test 'else' test */
  Sk.asserts.assert(NCH(n) === 5);
  return new Sk.astnodes.IfExp(ast_for_expr(c, CHILD(n, 2)), ast_for_expr(c, CHILD(n, 0)), ast_for_expr(c, CHILD(n, 4)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}
/**
 * s is a python-style string literal, including quote characters and u/r/b
 * prefixes. Returns decoded string object.
 */


function parsestr(c, s) {
  var encodeUtf8 = function encodeUtf8(s) {
    return unescape(encodeURIComponent(s));
  };

  var decodeUtf8 = function decodeUtf8(s) {
    return decodeURIComponent(escape(s));
  };

  var decodeEscape = function decodeEscape(s, quote) {
    var d3;
    var d2;
    var d1;
    var d0;
    var c;
    var i;
    var len = s.length;
    var ret = "";

    for (i = 0; i < len; ++i) {
      c = s.charAt(i);

      if (c === "\\") {
        ++i;
        c = s.charAt(i);

        if (c === "n") {
          ret += "\n";
        } else if (c === "\\") {
          ret += "\\";
        } else if (c === "t") {
          ret += "\t";
        } else if (c === "r") {
          ret += "\r";
        } else if (c === "b") {
          ret += "\b";
        } else if (c === "f") {
          ret += "\f";
        } else if (c === "v") {
          ret += "\v";
        } else if (c === "0") {
          ret += "\0";
        } else if (c === '"') {
          ret += '"';
        } else if (c === '\'') {
          ret += '\'';
        } else if (c === "\n")
          /* escaped newline, join lines */
          {} else if (c === "x") {
          d0 = s.charAt(++i);
          d1 = s.charAt(++i);
          ret += encodeUtf8(String.fromCharCode(parseInt(d0 + d1, 16)));
        } else if (c === "u" || c === "U") {
          d0 = s.charAt(++i);
          d1 = s.charAt(++i);
          d2 = s.charAt(++i);
          d3 = s.charAt(++i);
          ret += encodeUtf8(String.fromCharCode(parseInt(d0 + d1, 16), parseInt(d2 + d3, 16)));
        } else {
          // Leave it alone
          ret += "\\" + c; // Sk.asserts.fail("unhandled escape: '" + c.charCodeAt(0) + "'");
        }
      } else {
        ret += c;
      }
    }

    return decodeUtf8(ret);
  }; //print("parsestr", s);


  var quote = s.charAt(0);
  var rawmode = false;
  var unicode = false; // treats every sequence as unicodes even if they are not treated with uU prefix
  // kinda hacking though working for most purposes

  if (c.c_flags & Sk.Parser.CO_FUTURE_UNICODE_LITERALS || Sk.__future__.unicode_literals === true) {
    unicode = true;
  }

  if (quote === "u" || quote === "U") {
    s = s.substr(1);
    quote = s.charAt(0);
    unicode = true;
  } else if (quote === "r" || quote === "R") {
    s = s.substr(1);
    quote = s.charAt(0);
    rawmode = true;
  }

  Sk.asserts.assert(quote !== "b" && quote !== "B", "todo; haven't done b'' strings yet");
  Sk.asserts.assert(quote === "'" || quote === '"' && s.charAt(s.length - 1) === quote);
  s = s.substr(1, s.length - 2);

  if (unicode) {
    s = encodeUtf8(s);
  }

  if (s.length >= 4 && s.charAt(0) === quote && s.charAt(1) === quote) {
    Sk.asserts.assert(s.charAt(s.length - 1) === quote && s.charAt(s.length - 2) === quote);
    s = s.substr(2, s.length - 4);
  }

  if (rawmode || s.indexOf("\\") === -1) {
    return strobj(decodeUtf8(s));
  }

  return strobj(decodeEscape(s, quote));
}

function parsestrplus(c, n) {
  var i;
  var ret;
  REQ(CHILD(n, 0), TOK.T_STRING);
  ret = new Sk.builtin.str("");

  for (i = 0; i < NCH(n); ++i) {
    try {
      ret = ret.sq$concat(parsestr(c, CHILD(n, i).value));
    } catch (x) {
      console.error(x);
      throw new Sk.builtin.SyntaxError("invalid string (possibly contains a unicode character)", c.c_filename, CHILD(n, i).lineno);
    }
  }

  return ret;
}

function parsenumber(c, s, lineno) {
  var neg;
  var val;
  var tmp;
  var end = s.charAt(s.length - 1); // call internal complex type constructor for complex strings

  if (end === "j" || end === "J") {
    return Sk.builtin.complex.complex_subtype_from_string(s);
  } // Handle longs


  if (end === "l" || end === "L") {
    return Sk.longFromStr(s.substr(0, s.length - 1), 0);
  } // todo; we don't currently distinguish between int and float so
  // str is wrong for these.


  if (s.indexOf(".") !== -1) {
    return new Sk.builtin.float_(parseFloat(s));
  } // Handle integers of various bases


  tmp = s;
  neg = false;

  if (s.charAt(0) === "-") {
    tmp = s.substr(1);
    neg = true;
  }

  if (tmp.charAt(0) === "0" && (tmp.charAt(1) === "x" || tmp.charAt(1) === "X")) {
    // Hex
    tmp = tmp.substring(2);
    val = parseInt(tmp, 16);
  } else if (s.indexOf("e") !== -1 || s.indexOf("E") !== -1) {
    // Float with exponent (needed to make sure e/E wasn't hex first)
    return new Sk.builtin.float_(parseFloat(s));
  } else if (tmp.charAt(0) === "0" && (tmp.charAt(1) === "b" || tmp.charAt(1) === "B")) {
    // Binary
    tmp = tmp.substring(2);
    val = parseInt(tmp, 2);
  } else if (tmp.charAt(0) === "0") {
    if (tmp === "0") {
      // Zero
      val = 0;
    } else {
      // Octal
      tmp = tmp.substring(1);

      if (tmp.charAt(0) === "o" || tmp.charAt(0) === "O") {
        tmp = tmp.substring(1);
      }

      val = parseInt(tmp, 8);
    }
  } else {
    // Decimal
    val = parseInt(tmp, 10);
  } // Convert to long


  if (val > Sk.builtin.int_.threshold$ && Math.floor(val) === val && s.indexOf("e") === -1 && s.indexOf("E") === -1) {
    return Sk.longFromStr(s, 0);
  } // Small enough, return parsed number


  if (neg) {
    return new Sk.builtin.int_(-val);
  } else {
    return new Sk.builtin.int_(val);
  }
}

function astForSlice(c, n) {
  var n2;
  var step;
  var upper;
  var lower;
  var ch;
  REQ(n, SYM.subscript);
  /*
   subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
   sliceop: ':' [test]
   */

  ch = CHILD(n, 0);
  lower = null;
  upper = null;
  step = null;

  if (ch.type === TOK.T_DOT) {
    return new Sk.astnodes.Ellipsis();
  }

  if (NCH(n) === 1 && ch.type === SYM.test) {
    return new Sk.astnodes.Index(ast_for_expr(c, ch));
  }

  if (ch.type === SYM.test) {
    lower = ast_for_expr(c, ch);
  }

  if (ch.type === TOK.T_COLON) {
    if (NCH(n) > 1) {
      n2 = CHILD(n, 1);

      if (n2.type === SYM.test) {
        upper = ast_for_expr(c, n2);
      }
    }
  } else if (NCH(n) > 2) {
    n2 = CHILD(n, 2);

    if (n2.type === SYM.test) {
      upper = ast_for_expr(c, n2);
    }
  }

  ch = CHILD(n, NCH(n) - 1);

  if (ch.type === SYM.sliceop) {
    if (NCH(ch) === 1) {
      ch = CHILD(ch, 0);
      step = new Sk.astnodes.NameConstant(Sk.builtin.none.none$, Sk.astnodes.Load, ch.lineno, ch.col_offset, ch.end_lineno, ch.end_col_offset);
    } else {
      ch = CHILD(ch, 1);

      if (ch.type === SYM.test) {
        step = ast_for_expr(c, ch);
      }
    }
  }

  return new Sk.astnodes.Slice(lower, upper, step);
}

function ast_for_atom(c, n) {
  /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'
     | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+
     | '...' | 'None' | 'True' | 'False'
  */
  var ch = CHILD(n, 0);

  switch (TYPE(ch)) {
    case TOK.T_NAME:
      {
        var name;
        var s = STR(ch);

        if (s.length >= 4 && s.length <= 5) {
          if (s === "None") {
            return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
          }

          if (s === "True") {
            return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
          }

          if (s === "False") {
            return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
          }
        }

        name = new_identifier(s, c);
        /* All names start in Load context, but may later be changed. */

        return new Sk.astnodes.Name(name, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }

    case TOK.T_STRING:
      {
        var str = parsestrplus(c, n); // if (!str) {
        //     const char *errtype = NULL;
        //     if (PyErr_ExceptionMatches(PyExc_UnicodeError))
        //         errtype = "unicode error";
        //     else if (PyErr_ExceptionMatches(PyExc_ValueError))
        //         errtype = "value error";
        //     if (errtype) {
        //         PyObject *type, *value, *tback, *errstr;
        //         PyErr_Fetch(&type, &value, &tback);
        //         errstr = PyObject_Str(value);
        //         if (errstr) {
        //             ast_error(c, n, "(%s) %U", errtype, errstr);
        //             Py_DECREF(errstr);
        //         }
        //         else {
        //             PyErr_Clear();
        //             ast_error(c, n, "(%s) unknown error", errtype);
        //         }
        //         Py_DECREF(type);
        //         Py_XDECREF(value);
        //         Py_XDECREF(tback);
        //     }
        //     return NULL;
        // }

        return new Sk.astnodes.Str(str, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      }

    case TOK.T_NUMBER:
      return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_ELLIPSIS:
      /* Ellipsis */
      return new Sk.astnodes.Ellipsis(LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_LPAR:
      /* some parenthesized expressions */
      ch = CHILD(n, 1);
      if (TYPE(ch) == TOK.T_RPAR) return new Sk.astnodes.Tuple([], Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);

      if (TYPE(ch) == SYM.yield_expr) {
        return ast_for_expr(c, ch);
      }
      /* testlist_comp: test ( comp_for | (',' test)* [','] ) */


      if (NCH(ch) == 1) {
        return ast_for_testlist(c, ch);
      }

      if (TYPE(CHILD(ch, 1)) == SYM.comp_for) {
        return copy_location(ast_for_genexp(c, ch), n);
      } else {
        return copy_location(ast_for_testlist(c, ch), n);
      }

    case TOK.T_LSQB:
      /* list (or list comprehension) */
      ch = CHILD(n, 1);
      if (TYPE(ch) == TOK.T_RSQB) return new Sk.astnodes.List([], Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      REQ(ch, SYM.testlist_comp);

      if (NCH(ch) == 1 || TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {
        var elts = seq_for_testlist(c, ch);

        if (!elts) {
          return null;
        }

        return new Sk.astnodes.List(elts, Sk.astnodes.Load, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
      } else {
        return copy_location(ast_for_listcomp(c, ch), n);
      }

    case TOK.T_LBRACE:
      {
        /* dictorsetmaker: ( ((test ':' test | '**' test)
        *                    (comp_for | (',' (test ':' test | '**' test))* [','])) |
        *                   ((test | '*' test)
        *                    (comp_for | (',' (test | '*' test))* [','])) ) */
        var res;
        ch = CHILD(n, 1);

        if (TYPE(ch) == TOK.T_RBRACE) {
          /* It's an empty dict. */
          return new Sk.astnodes.Dict(null, null, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
        } else {
          var is_dict = TYPE(CHILD(ch, 0)) == TOK.T_DOUBLESTAR;

          if (NCH(ch) == 1 || NCH(ch) > 1 && TYPE(CHILD(ch, 1)) == TOK.T_COMMA) {
            /* It's a set display. */
            res = ast_for_setdisplay(c, ch);
          } else if (NCH(ch) > 1 && TYPE(CHILD(ch, 1)) == SYM.comp_for) {
            /* It's a set comprehension. */
            res = ast_for_setcomp(c, ch);
          } else if (NCH(ch) > 3 - is_dict && TYPE(CHILD(ch, 3 - is_dict)) == SYM.comp_for) {
            /* It's a dictionary comprehension. */
            if (is_dict) {
              ast_error(c, n, "dict unpacking cannot be used in dict comprehension");
              return null;
            }

            res = ast_for_dictcomp(c, ch);
          } else {
            /* It's a dictionary display. */
            res = ast_for_dictdisplay(c, ch);
          }

          return copy_location(res, n);
        }
      }

    default:
      Sk.assert.fail("unhandled atom " + TYPE(ch));
      return null;
  }
}

function ast_for_setdisplay(c, n) {
  var i;
  var elts = [];
  Sk.asserts.assert(TYPE(n) === SYM.dictorsetmaker);

  for (i = 0; i < NCH(n); i += 2) {
    var expression;
    expression = ast_for_expr(c, CHILD(n, i));
    elts[i / 2] = expression;
  }

  return new Sk.astnodes.Set(elts, LINENO(n), n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForAtom(c, n) {
  /* atom: '(' [yield_expr|testlist_comp] ')' | '[' [testlist_comp] ']'
     | '{' [dictmaker|testlist_comp] '}' | NAME | NUMBER | STRING+
     | '...' | 'None' | 'True' | 'False'
  */
  var i;
  var values;
  var keys;
  var size;
  var ch = CHILD(n, 0);
  var elts;

  switch (ch.type) {
    case TOK.T_NAME:
      var s = ch.value; // All names start in Load context, but may be changed later

      if (s.length >= 4 && s.length <= 5) {
        if (s === "None") {
          return new Sk.astnodes.NameConstant(Sk.builtin.none.none$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
          /* c.c_arena*/
          );
        }

        if (s === "True") {
          return new Sk.astnodes.NameConstant(Sk.builtin.bool.true$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
          /* c.c_arena*/
          );
        }

        if (s === "False") {
          return new Sk.astnodes.NameConstant(Sk.builtin.bool.false$, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
          /* c.c_arena*/
          );
        }
      }

      var name = new_identifier(s, c);
      /* All names start in Load context, but may later be changed. */

      return new Sk.astnodes.Name(name, Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_STRING:
      return new Sk.astnodes.Str(parsestrplus(c, n), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_NUMBER:
      return new Sk.astnodes.Num(parsenumber(c, ch.value, n.lineno), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    case TOK.T_LPAR:
      // various uses for parens
      ch = CHILD(n, 1);

      if (ch.type === TOK.T_RPAR) {
        return new Sk.astnodes.Tuple([], Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      }

      if (ch.type === SYM.yield_expr) {
        return ast_for_expr(c, ch);
      } //            if (NCH(ch) > 1 && CHILD(ch, 1).type === SYM.comp_for) {
      //                return astForComprehension(c, ch);
      //            }


      return ast_for_testlistComp(c, ch);

    case TOK.T_LSQB:
      // list or listcomp
      ch = CHILD(n, 1);

      if (ch.type === TOK.T_RSQB) {
        return new Sk.astnodes.List([], Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      }

      REQ(ch, SYM.listmaker);

      if (NCH(ch) === 1 || CHILD(ch, 1).type === TOK.T_COMMA) {
        return new Sk.astnodes.List(seq_for_testlist(c, ch), Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      }

      return ast_for_listcomp(c, ch);

    case TOK.T_LBRACE:
      /* dictorsetmaker:
       *     (test ':' test (comp_for : (',' test ':' test)* [','])) |
       *     (test (comp_for | (',' test)* [',']))
       */
      keys = [];
      values = [];
      ch = CHILD(n, 1);

      if (n.type === TOK.T_RBRACE) {
        //it's an empty dict
        return new Sk.astnodes.Dict([], null, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      } else if (NCH(ch) === 1 || NCH(ch) !== 0 && CHILD(ch, 1).type === TOK.T_COMMA) {
        //it's a simple set
        elts = [];
        size = Math.floor((NCH(ch) + 1) / 2);

        for (i = 0; i < NCH(ch); i += 2) {
          var expression = ast_for_expr(c, CHILD(ch, i));
          elts[i / 2] = expression;
        }

        return new Sk.astnodes.Set(elts, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      } else if (NCH(ch) !== 0 && CHILD(ch, 1).type == SYM.comp_for) {
        //it's a set comprehension
        return ast_for_setcomp(c, ch);
      } else if (NCH(ch) > 3 && CHILD(ch, 3).type === SYM.comp_for) {
        //it's a dict compr. I think.
        return ast_for_dictcomp(c, ch);
      } else {
        size = Math.floor((NCH(ch) + 1) / 4); // + 1 for no trailing comma case

        for (i = 0; i < NCH(ch); i += 4) {
          keys[i / 4] = ast_for_expr(c, CHILD(ch, i));
          values[i / 4] = ast_for_expr(c, CHILD(ch, i + 2));
        }

        return new Sk.astnodes.Dict(keys, values, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
      }

    case TOK.T_BACKQUOTE:
      //throw new Sk.builtin.SyntaxError("backquote not supported, use repr()", c.c_filename, n.lineno);
      return new Sk.astnodes.Repr(ast_for_testlist(c, CHILD(n, 1)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

    default:
      Sk.asserts.fail("unhandled atom", ch.type);
  }
}

function astForAtomExpr(c, n) {
  var i,
      nch,
      start = 0;
  var e, tmp;
  REQ(n, SYM.atom_expr);
  nch = NCH(n);

  if (CHILD(n, 0).type === TOK.T_AWAIT) {
    start = 1;
    Sk.asserts.assert(nch > 1);
  }

  e = ast_for_atom(c, CHILD(n, start));

  if (!e) {
    return null;
  }

  if (nch === 1) {
    return e;
  }

  if (start && nch === 2) {
    return new Sk.astnodes.Await(e, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
    /*, c->c_arena*/
    );
  }

  for (i = start + 1; i < nch; i++) {
    var ch = CHILD(n, i);

    if (ch.type !== SYM.trailer) {
      break;
    }

    tmp = ast_for_trailer(c, ch, e);

    if (!tmp) {
      return null;
    }

    tmp.lineno = e.lineno;
    tmp.col_offset = e.col_offset;
    e = tmp;
  }

  if (start) {
    /* there was an AWAIT */
    return new Sk.astnodes.Await(e, n.line, n.col_offset, n.end_lineno, n.end_col_offset
    /*, c->c_arena*/
    );
  } else {
    return e;
  }
}

function astForPower(c, n) {
  /* power: atom trailer* ('**' factor)*
   */
  var f;
  var tmp;
  var ch;
  var i;
  var e;
  REQ(n, SYM.power);
  e = astForAtomExpr(c, CHILD(n, 0));

  if (NCH(n) === 1) {
    return e;
  }

  if (CHILD(n, NCH(n) - 1).type === SYM.factor) {
    f = ast_for_expr(c, CHILD(n, NCH(n) - 1));
    e = new Sk.astnodes.BinOp(e, Sk.astnodes.Pow, f, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
  }

  return e;
}

function astForStarred(c, n) {
  REQ(n, SYM.star_expr);
  /* The Load context is changed later */

  return new Sk.astnodes.Starred(ast_for_expr(c, CHILD(n, 1)), Sk.astnodes.Load, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
  /*, c.c_arena */
  );
}

function ast_for_expr(c, n) {
  /*
   handle the full range of simple expressions
   test: or_test ['if' or_test 'else' test] | lambdef
   test_nocond: or_test | lambdef_nocond
   or_test: and_test ('or' and_test)*
   and_test: not_test ('and' not_test)*
   not_test: 'not' not_test | comparison
   comparison: expr (comp_op expr)*
   expr: xor_expr ('|' xor_expr)*
   xor_expr: and_expr ('^' and_expr)*
   and_expr: shift_expr ('&' shift_expr)*
   shift_expr: arith_expr (('<<'|'>>') arith_expr)*
   arith_expr: term (('+'|'-') term)*
   term: factor (('*'|'/'|'%'|'//') factor)*
   factor: ('+'|'-'|'~') factor | power
   power: atom_expr ['**' factor]
   atom_expr: [AWAIT] atom trailer*
   yield_expr: 'yield' [yield_arg]
  */
  var exp;
  var cmps;
  var ops;
  var i;
  var seq;

  LOOP: while (true) {
    switch (n.type) {
      case SYM.test:
      case SYM.test_nocond:
        if (CHILD(n, 0).type === SYM.lambdef || CHILD(n, 0).type === SYM.lambdef_nocond) {
          return astForLambdef(c, CHILD(n, 0));
        } else if (NCH(n) > 1) {
          return astForIfexpr(c, n);
        }

      // fallthrough

      case SYM.or_test:
      case SYM.and_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }

        seq = [];

        for (i = 0; i < NCH(n); i += 2) {
          seq[i / 2] = ast_for_expr(c, CHILD(n, i));
        }

        if (CHILD(n, 1).value === "and") {
          return new Sk.astnodes.BoolOp(Sk.astnodes.And, seq, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset
          /*, c.c_arena*/
          );
        }

        Sk.asserts.assert(CHILD(n, 1).value === "or");
        return new Sk.astnodes.BoolOp(Sk.astnodes.Or, seq, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

      case SYM.not_test:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          return new Sk.astnodes.UnaryOp(Sk.astnodes.Not, ast_for_expr(c, CHILD(n, 1)), n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
        }

        break;

      case SYM.comparison:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        } else {
          ops = [];
          cmps = [];

          for (i = 1; i < NCH(n); i += 2) {
            ops[(i - 1) / 2] = astForCompOp(c, CHILD(n, i));
            cmps[(i - 1) / 2] = ast_for_expr(c, CHILD(n, i + 1));
          }

          return new Sk.astnodes.Compare(ast_for_expr(c, CHILD(n, 0)), ops, cmps, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
        }

        break;

      case SYM.star_expr:
        return astForStarred(c, n);

      /* The next fize cases all handle BinOps  The main body of code
         is the same in each case, but the switch turned inside out to
         reuse the code for each type of operator
       */

      case SYM.expr:
      case SYM.xor_expr:
      case SYM.and_expr:
      case SYM.shift_expr:
      case SYM.arith_expr:
      case SYM.term:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }

        return astForBinop(c, n);

      case SYM.yield_expr:
        var an;
        var en;
        var is_from = false;
        exp = null;

        if (NCH(n) > 1) {
          an = CHILD(n, 1);
          /* yield_arg */
        }

        if (an) {
          en = CHILD(an, NCH(an) - 1);

          if (NCH(an) == 2) {
            is_from = true;
            exp = ast_for_expr(c, en);
          } else {
            exp = ast_for_testlist(c, en);
          }
        }

        if (is_from) {
          return new Sk.astnodes.YieldFrom(exp, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
        }

        return new Sk.astnodes.Yield(exp, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

      case SYM.factor:
        if (NCH(n) === 1) {
          n = CHILD(n, 0);
          continue LOOP;
        }

        return astForFactor(c, n);

      case SYM.power:
        return astForPower(c, n);

      default:
        Sk.asserts.fail("unhandled expr", "n.type: %d", n.type);
    }

    break;
  }
}

function astForNonLocalStmt(c, n) {
  ast_error(c, n, "Not implemented: nonlocal");
}

function astForAsyncStmt(c, n) {
  ast_error(c, n, "Not implemented: async");
} // This is only used for Python 2 support.


function astForPrintStmt(c, n) {
  if (Sk.__future__.print_function) {
    ast_error(c, n, "Missing parentheses in call to 'print'");
  }
  /* print_stmt: 'print' ( [ test (',' test)* [','] ]
   | '>>' test [ (',' test)+ [','] ] )
   */


  var nl;
  var i, j;
  var seq;
  var start = 1;
  var dest = null;
  REQ(n, SYM.print_stmt);

  if (NCH(n) >= 2 && CHILD(n, 1).type === TOK.T_RIGHTSHIFT) {
    dest = ast_for_expr(c, CHILD(n, 2));
    start = 4;
  }

  seq = [];

  for (i = start, j = 0; i < NCH(n); i += 2, ++j) {
    seq[j] = ast_for_expr(c, CHILD(n, i));
  }

  nl = CHILD(n, NCH(n) - 1).type === TOK.T_COMMA ? false : true;
  return new Sk.astnodes.Print(dest, seq, nl, n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);
}

function astForStmt(c, n) {
  var ch;

  if (n.type === SYM.stmt) {
    Sk.asserts.assert(NCH(n) === 1);
    n = CHILD(n, 0);
  }

  if (n.type === SYM.simple_stmt) {
    Sk.asserts.assert(numStmts(n) === 1);
    n = CHILD(n, 0);
  }

  if (n.type === SYM.small_stmt) {
    n = CHILD(n, 0);
    /* small_stmt: expr_stmt | del_stmt | pass_stmt | flow_stmt
               | import_stmt | global_stmt | nonlocal_stmt | assert_stmt
               | debugger_stmt (skulpt special)
    */

    switch (n.type) {
      case SYM.expr_stmt:
        return ast_for_exprStmt(c, n);

      case SYM.del_stmt:
        return astForDelStmt(c, n);

      case SYM.pass_stmt:
        return new Sk.astnodes.Pass(n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

      case SYM.flow_stmt:
        return ast_for_flow_stmt(c, n);

      case SYM.import_stmt:
        return astForImportStmt(c, n);

      case SYM.global_stmt:
        return astForGlobalStmt(c, n);

      case SYM.nonlocal_stmt:
        return astForNonLocalStmt(c, n);

      case SYM.assert_stmt:
        return astForAssertStmt(c, n);

      case SYM.print_stmt:
        return astForPrintStmt(c, n);

      case SYM.debugger_stmt:
        return new Sk.astnodes.Debugger(n.lineno, n.col_offset, n.end_lineno, n.end_col_offset);

      default:
        Sk.asserts.fail("unhandled small_stmt");
    }
  } else {
    /* compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt
                    | funcdef | classdef | decorated | async_stmt
    */
    ch = CHILD(n, 0);
    REQ(n, SYM.compound_stmt);

    switch (ch.type) {
      case SYM.if_stmt:
        return astForIfStmt(c, ch);

      case SYM.while_stmt:
        return astForWhileStmt(c, ch);

      case SYM.for_stmt:
        return astForForStmt(c, ch);

      case SYM.try_stmt:
        return astForTryStmt(c, ch);

      case SYM.with_stmt:
        return ast_for_with_stmt(c, ch);

      case SYM.funcdef:
        return ast_for_funcdef(c, ch, []);

      case SYM.classdef:
        return astForClassdef(c, ch, []);

      case SYM.decorated:
        return ast_for_decorated(c, ch);

      case SYM.async_stmt:
        return astForAsyncStmt(c, ch);

      default:
        Sk.asserts.assert("unhandled compound_stmt");
    }
  }
}

;

Sk.astFromParse = function (n, filename, c_flags) {
  var j;
  var num;
  var ch;
  var i;
  var c = new Compiling("utf-8", filename, c_flags);
  var stmts = [];
  var k = 0;

  switch (n.type) {
    case SYM.file_input:
      for (i = 0; i < NCH(n) - 1; ++i) {
        ch = CHILD(n, i);

        if (n.type === TOK.T_NEWLINE) {
          continue;
        }

        REQ(ch, SYM.stmt);
        num = numStmts(ch);

        if (num === 1) {
          stmts[k++] = astForStmt(c, ch);
        } else {
          ch = CHILD(ch, 0);
          REQ(ch, SYM.simple_stmt);

          for (j = 0; j < num; ++j) {
            stmts[k++] = astForStmt(c, CHILD(ch, j * 2));
          }
        }
      }

      return new Sk.astnodes.Module(stmts);

    case SYM.eval_input:
      Sk.asserts.fail("todo;");

    case SYM.single_input:
      Sk.asserts.fail("todo;");

    default:
      Sk.asserts.fail("todo;");
  }
};

Sk.astDump = function (node) {
  var spaces = function spaces(n) // todo; blurgh
  {
    var i;
    var ret = "";

    for (i = 0; i < n; ++i) {
      ret += " ";
    }

    return ret;
  };

  var _format = function _format(node, indent) {
    var ret;
    var elemsstr;
    var x;
    var elems;
    var fieldstr;
    var field;
    var attrs;
    var fieldlen;
    var b;
    var a;
    var i;
    var fields;
    var namelen;

    if (node === null) {
      return indent + "None";
    } else if (node.prototype && node.prototype._astname !== undefined && node.prototype._isenum) {
      return indent + node.prototype._astname + "()";
    } else if (node._astname !== undefined) {
      namelen = spaces(node._astname.length + 1);
      fields = [];

      for (i = 0; i < node._fields.length; i += 2) // iter_fields
      {
        a = node._fields[i]; // field name

        b = node._fields[i + 1](node); // field getter func

        fieldlen = spaces(a.length + 1);
        fields.push([a, _format(b, indent + namelen + fieldlen)]);
      }

      attrs = [];

      for (i = 0; i < fields.length; ++i) {
        field = fields[i];
        attrs.push(field[0] + "=" + field[1].replace(/^\s+/, ""));
      }

      fieldstr = attrs.join(",\n" + indent + namelen);
      return indent + node._astname + "(" + fieldstr + ")";
    } else if (Sk.isArrayLike(node)) {
      //Sk.debugout("arr", node.length);
      elems = [];

      for (i = 0; i < node.length; ++i) {
        x = node[i];
        elems.push(_format(x, indent + " "));
      }

      elemsstr = elems.join(",\n");
      return indent + "[" + elemsstr.replace(/^\s+/, "") + "]";
    } else {
      if (node === true) {
        ret = "True";
      } else if (node === false) {
        ret = "False";
      } else if (node instanceof Sk.builtin.lng) {
        ret = node.tp$str().v;
      } else if (node instanceof Sk.builtin.str) {
        ret = node["$r"]().v;
      } else {
        ret = "" + node;
      }

      return indent + ret;
    }
  };

  return _format(node, "");
};

Sk.INHERITANCE_MAP = {
  'mod': [Sk.astnodes.Module, Sk.astnodes.Interactive, Sk.astnodes.Expression, Sk.astnodes.Suite],
  'stmt': [Sk.astnodes.FunctionDef, Sk.astnodes.AsyncFunctionDef, Sk.astnodes.ClassDef, Sk.astnodes.Return, Sk.astnodes.Delete, Sk.astnodes.Assign, Sk.astnodes.AugAssign, Sk.astnodes.AnnAssign, Sk.astnodes.For, Sk.astnodes.AsyncFor, Sk.astnodes.While, Sk.astnodes.If, Sk.astnodes.With, Sk.astnodes.AsyncWith, Sk.astnodes.Raise, Sk.astnodes.Try, Sk.astnodes.Assert, Sk.astnodes.Import, Sk.astnodes.ImportFrom, Sk.astnodes.Global, Sk.astnodes.Nonlocal, Sk.astnodes.Expr, Sk.astnodes.Pass, Sk.astnodes.Break, Sk.astnodes.Continue, Sk.astnodes.Print, Sk.astnodes.Debugger],
  'expr': [Sk.astnodes.BoolOp, Sk.astnodes.BinOp, Sk.astnodes.UnaryOp, Sk.astnodes.Lambda, Sk.astnodes.IfExp, Sk.astnodes.Dict, Sk.astnodes.Set, Sk.astnodes.ListComp, Sk.astnodes.SetComp, Sk.astnodes.DictComp, Sk.astnodes.GeneratorExp, Sk.astnodes.Await, Sk.astnodes.Yield, Sk.astnodes.YieldFrom, Sk.astnodes.Compare, Sk.astnodes.Call, Sk.astnodes.Num, Sk.astnodes.Str, Sk.astnodes.FormattedValue, Sk.astnodes.JoinedStr, Sk.astnodes.Bytes, Sk.astnodes.Ellipsis, Sk.astnodes.NameConstant, Sk.astnodes.Constant, Sk.astnodes.Attribute, Sk.astnodes.Subscript, Sk.astnodes.Starred, Sk.astnodes.Name, Sk.astnodes.List, Sk.astnodes.Tuple],
  'expr_context': [Sk.astnodes.Load, Sk.astnodes.Store, Sk.astnodes.Del, Sk.astnodes.AugLoad, Sk.astnodes.AugStore, Sk.astnodes.Param],
  'slice': [Sk.astnodes.Slice, Sk.astnodes.ExtSlice, Sk.astnodes.Index],
  'boolop': [Sk.astnodes.And, Sk.astnodes.Or],
  'operator': [Sk.astnodes.Add, Sk.astnodes.Sub, Sk.astnodes.Mult, Sk.astnodes.MatMult, Sk.astnodes.Div, Sk.astnodes.Mod, Sk.astnodes.Pow, Sk.astnodes.LShift, Sk.astnodes.RShift, Sk.astnodes.BitOr, Sk.astnodes.BitXor, Sk.astnodes.BitAnd, Sk.astnodes.FloorDiv],
  'unaryop': [Sk.astnodes.Invert, Sk.astnodes.Not, Sk.astnodes.UAdd, Sk.astnodes.USub],
  'cmpop': [Sk.astnodes.Eq, Sk.astnodes.NotEq, Sk.astnodes.Lt, Sk.astnodes.LtE, Sk.astnodes.Gt, Sk.astnodes.GtE, Sk.astnodes.Is, Sk.astnodes.IsNot, Sk.astnodes.In, Sk.astnodes.NotIn],
  'comprehension': [],
  'excepthandler': [Sk.astnodes.ExceptHandler],
  'arguments_': [],
  'arg': [],
  'keyword': [],
  'alias': [],
  'withitem': []
};
Sk.exportSymbol("Sk.astFromParse", Sk.astFromParse);
Sk.exportSymbol("Sk.astDump", Sk.astDump);
Sk.exportSymbol("Sk.INHERITANCE_MAP", Sk.INHERITANCE_MAP);